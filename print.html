<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Thin Edge Specifications</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="telemetry-data/index.html"><strong aria-hidden="true">1.</strong> Telemetry Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="telemetry-data/thin-edge-json.html"><strong aria-hidden="true">1.1.</strong> Thin Edge Json</a></li><li class="chapter-item expanded "><a href="telemetry-data/mqtt-bus.html"><strong aria-hidden="true">1.2.</strong> MQTT Bus</a></li></ol></li><li class="chapter-item expanded "><a href="supported-operations/index.html"><strong aria-hidden="true">2.</strong> Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="supported-operations/requirements.html"><strong aria-hidden="true">2.1.</strong> Requirements</a></li><li class="chapter-item expanded "><a href="supported-operations/principles.html"><strong aria-hidden="true">2.2.</strong> Principles</a></li><li class="chapter-item expanded "><a href="supported-operations/thin-edge-supported-operations.html"><strong aria-hidden="true">2.3.</strong> Examples</a></li><li class="chapter-item expanded "><a href="supported-operations/command-line-support.html"><strong aria-hidden="true">2.4.</strong> Command line support</a></li></ol></li><li class="chapter-item expanded "><a href="software-management/index.html"><strong aria-hidden="true">3.</strong> Software management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="software-management/usecase-update-swlist.html"><strong aria-hidden="true">3.1.</strong> Use-Case Update Software-List</a></li><li class="chapter-item expanded "><a href="software-management/plugin-api.html"><strong aria-hidden="true">3.2.</strong> Package Manager Plugin API</a></li><li class="chapter-item expanded "><a href="software-management/sm-agent.html"><strong aria-hidden="true">3.3.</strong> Software Management Agent</a></li><li class="chapter-item expanded "><a href="software-management/c8y-mapper-operation-handling.html"><strong aria-hidden="true">3.4.</strong> C8Y Mapper Operation Handling</a></li><li class="chapter-item expanded "><a href="software-management/thin-edge-json-mapping-to-from-c8y.html"><strong aria-hidden="true">3.5.</strong> Thin Edge JSON Mapping to/from C8Y</a></li></ol></li><li class="chapter-item expanded "><a href="decisions/open-decisions.html"><strong aria-hidden="true">4.</strong> Open Decisions</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Thin Edge Specifications</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- toc -->
<h1 id="sourcing-processing-and-publishing-telemetry-data"><a class="header" href="#sourcing-processing-and-publishing-telemetry-data">Sourcing, Processing and Publishing Telemetry Data</a></h1>
<p>Thin-edge.io primary use-case is to:</p>
<ol>
<li>collect telemetry data on a device from various sources, sensors, and child devices,</li>
<li>process these data with analytics components</li>
<li>forward part of the processed to the cloud.</li>
</ol>
<p>This flow of data is organized over :</p>
<ol>
<li>an <a href="telemetry-data/./mqtt-bus.html">MQTT bus</a> where the local components publish and exchange messages,</li>
<li>a canonical data format, <a href="telemetry-data/./thin-edge-json.html">thin-edge-json</a>, that let the components exchange telemetry data
independently of the connected cloud</li>
<li>a mapper process that translates canonical messages and forward them to the cloud.</li>
</ol>
<pre class="mermaid">graph TD
    src(Source)
    c8y(C8y Cloud)
    az(Azure Cloud)

    mapSrc((Source Mapper))
    proc((Analytics))
    mapAz((C8y Mapper))
    mapC8y((Azure Mapper))

    subgraph Mqtt Bus
        raw&gt;Source specific messages]
        tej&gt;Thin Edge Json messages]
        cloud&gt;Cloud specific messages]
        bridge&gt;Bridge]
    end

    src --&gt; raw
    raw --&gt; mapSrc --&gt; tej
    tej --&gt; proc --&gt; tej
    tej --&gt; mapC8y --&gt; cloud
    tej --&gt; mapAz --&gt; cloud
    cloud --&gt; bridge --&gt; c8y
    cloud --&gt; bridge --&gt; az
</pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="thin-edge-json"><a class="header" href="#thin-edge-json">Thin-Edge-Json</a></h1>
<p>Thin Edge JSON is a lightweight format used in <code>thin-edge.io</code> to represent measurements data.
This format can be used to represent single-valued measurements, multi-valued measurements
or a combination of both along with some auxiliary data like the timestamp at which the measurement(s) was generated.</p>
<h2 id="single-valued-measurements"><a class="header" href="#single-valued-measurements">Single-valued measurements</a></h2>
<p>Simple single-valued measurements like temperature or pressure measurement with a single value can be expressed as follows:</p>
<pre><code class="language-json">{
    &quot;temperature&quot;: 25
}
</code></pre>
<p>where the key represents the measurement type, and the value represents the measurement value.
The keys can only have alphanumeric characters, and the &quot;_&quot; (underscore) character but must not start with an underscore.
The values can only be numeric.
String, Boolean or other JSON object values are not allowed.</p>
<h2 id="multi-valued-measurements"><a class="header" href="#multi-valued-measurements">Multi-valued measurements</a></h2>
<p>A multi-valued measurement is a measurement that is comprised of multiple values. Here is the representation of a
<code>three_phase_current</code> measurement that consists of <code>L1</code>, <code>L2</code> and <code>L3</code> values, representing the current on each phase:</p>
<pre><code class="language-json">{
    &quot;three_phase_current&quot;: {
      &quot;L1&quot;: 9.5,
      &quot;L2&quot;: 10.3,
      &quot;L3&quot;: 8.8
    }
}
</code></pre>
<p>where the key is the top-level measurement type and value is a JSON object having further key-value pairs 
representing each aspect of the multi-valued measurement.
Only one level of nesting is allowed, meaning the values of the measurement keys at the inner level can only be numeric values.
For example, a multi-level measurement as follows is NOT valid: </p>
<pre><code class="language-json">{ 
    &quot;three_phase_current&quot;: {
        &quot;phase1&quot;: {
            &quot;L1&quot;: 9.5
        },
        &quot;phase2&quot;: {
            &quot;L2&quot;: 10.3
        },
        &quot;phase3&quot;: {
            &quot;L3&quot;: 8.8
        }
    }
}
</code></pre>
<p>because the values at the second level(<code>phase1</code>, <code>phase2</code> and <code>phase3</code>) are not numeric values.</p>
<h2 id="grouping-measurements"><a class="header" href="#grouping-measurements">Grouping measurements</a></h2>
<p>Multiple single-valued and multi-valued measurements can be grouped into a single Thin Edge JSON message as follows:</p>
<pre><code class="language-json">{ 
    &quot;temperature&quot;: 25,
    &quot;three_phase_current&quot;: {
        &quot;L1&quot;: 9.5,
        &quot;L2&quot;: 10.3,
        &quot;L3&quot;: 8.8
    },
    &quot;pressure&quot;: 98 
}
</code></pre>
<p>The grouping of measurements is usually done to represent measurements collected at the same instant of time.</p>
<h2 id="auxiliary-measurement-data"><a class="header" href="#auxiliary-measurement-data">Auxiliary measurement data</a></h2>
<p>When <code>thin-edge.io</code> receives a measurement, it will add a timestamp to it before any further processing.
If the user doesn't want to rely on <code>thin-edge.io</code> generated timestamps,
an explicit timestamp can be provided in the measurement message itself by adding the time value as a string 
in ISO 8601 format using <code>time</code> as the key name, as follows:</p>
<pre><code class="language-json">{ 
    &quot;time&quot;: &quot;2020-10-15T05:30:47+00:00&quot;, 
    &quot;temperature&quot;: 25, 
    &quot;location&quot;: { 
        &quot;latitude&quot;: 32.54, 
        &quot;longitude&quot;: -117.67, 
        &quot;altitude&quot;: 98.6 
    }, 
    &quot;pressure&quot;: 98 
}
</code></pre>
<p>The <code>time</code> key is a reserved keyword and hence can not be used as a measurement key.
The <code>time</code> field must be defined at the root level of the measurement JSON and not allowed at any other level,
like inside the object value of a multi-valued measurement.
Non-numeric values like the ISO 8601 timestamp string are allowed only for such reserved keys and not for regular measurements. </p>
<p>Here is the complete list of reserved keys that has special meanings inside the <code>thin-edge.io</code> framework
and hence must not be used as measurement keys:</p>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td>time</td><td>Timestamp in ISO 8601 string format</td></tr>
<tr><td>type</td><td>Internal to <code>thin-edge.io</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="the-thin-edge-mqtt-bus"><a class="header" href="#the-thin-edge-mqtt-bus">The Thin Edge MQTT bus</a></h1>
<h2 id="sending-measurements-to-thin-edgeio"><a class="header" href="#sending-measurements-to-thin-edgeio">Sending measurements to thin-edge.io</a></h2>
<p>The <code>thin-edge.io</code> framework exposes some MQTT endpoints that can be used by local processes
to exchange data between themselves as well as to get some data forwarded to the cloud.
It will essentially act like an MQTT broker against which you can write your application logic.
Other thin-edge processes can use this broker as an inter-process communication mechanism by publishing and 
subscribing to various MQTT topics.
Any data can be forwarded to the connected cloud-provider as well, by publishing the data to some standard topics.</p>
<p>All topics with the prefix <code>tedge/</code> are reserved by <code>thin-edge.io</code> for this purpose.
To send measurements to <code>thin-edge.io</code>, the measurements represented in Thin Edge JSON format can be published 
to the <code>tedge/measurements</code> topic.
Other processes running on the thin-edge device can subscribe to this topic to process these measurements.</p>
<p>If the messages published to this <code>tedge/measurements</code> topic is not a well-formed Thin Edge JSON, 
then that message won’t be processed by <code>thin-edge.io</code>, not even partially,
and an appropriate error message on why the validation failed will be published to a dedicated <code>tedge/errors</code> topic.
The messages published to this topic will be highly verbose error messages and can be used for any debugging during development.
You should not rely on the structure of these error messages to automate any actions as they are purely textual data 
and bound to change from time-to-time.</p>
<p>More topics will be added under the <code>tedge/</code> topic in future to support more data types like events, alarms etc.
So, it is advised to avoid any sub-topics under <code>tedge/</code> for any other data exchange between processes.</p>
<p>Here is the complete list of topics reserved by <code>thin-edge.io</code> for its internal working:</p>
<table><thead><tr><th>Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>tedge/</code></td><td>Reserved root topic of <code>thin-edge.io</code></td></tr>
<tr><td><code>tedge/measurements</code></td><td>Topic to publish measurements to <code>thin-edge.io</code></td></tr>
<tr><td><code>tedge/errors</code></td><td>Topic to subscribe to receive any error messages emitted by <code>thin-edge.io</code> while processing measurements</td></tr>
</tbody></table>
<h2 id="sending-measurements-to-the-cloud"><a class="header" href="#sending-measurements-to-the-cloud">Sending measurements to the cloud</a></h2>
<p>The <code>thin-edge.io</code> framework allows users forward all the measurements generated and published to
<code>tedge/measurements</code> MQTT topic in the thin-edge device to any IoT cloud provider that it is connected to,
with the help of a <em>mapper</em> component designed for that cloud.
The responsibility of a mapper is to subscribe to the <code>tedge/measurements</code> topic to receive all incoming measurements 
represented in the cloud vendor neutral Thin Edge JSON format, to a format that the connected cloud understands.
Refer to <a href="telemetry-data/./mapper.html">Cloud Message Mapper Architecture</a> for more details on the mapper component.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensible-support-of-operations"><a class="header" href="#extensible-support-of-operations">Extensible support of operations</a></h1>
<p>The main features of thin-edge can be extended with plugins that provide specific support for new operations,
that can be then triggered from the cloud or from other components.</p>
<p>An operation can be as simple as executing ad-hoc commands or as complex as installing new software versions
on the thin-edge device. Other examples are the abilities to upload log files
or to open an ssh-tunnel from the cloud to the device.</p>
<p>On a device, an operation is materialized by an executable that interacts with the cloud end-point via thin-edge.</p>
<ul>
<li>Some operations are provided by thin-edge (for instance <em>Software Management</em>).</li>
<li>New operations can be added by tier parties using any programming language.</li>
<li>In order to be open and flexible, thin-edge sets no constraint on the protocol
used by a plugin to interact with the cloud and the device local services.</li>
<li>For each supported cloud, Thin-edge provides the mechanisms:
<ul>
<li>to register operation plugins on the device,</li>
<li>to notify the connected cloud instance with the set of operations supported by the device,</li>
<li>to notify the appropriate operation plugin when an operation request is triggered from the cloud.</li>
</ul>
</li>
<li>The implementation of an operation might be cloud specific or not.
<ul>
<li>If not, the implementation has to provide protocol-translation mechanisms around the main operation mechanism.</li>
</ul>
</li>
</ul>
<p>TOC:</p>
<ul>
<li><a href="supported-operations/./requirements.html">Requirements</a></li>
<li><a href="supported-operations/./principles.html">Principles</a></li>
<li><a href="supported-operations/./thin-edge-supported-operations.html">Examples</a></li>
<li><a href="supported-operations/./command-line-support.html">Command line support</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirements-for-operation-support"><a class="header" href="#requirements-for-operation-support">Requirements for Operation Support</a></h1>
<h2 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h2>
<ul>
<li>One should be able to add new features to thin-edge with operation plugins.</li>
<li>An operation can be as simple as executing ad-hoc commands on behalf of a remote use
or as complex as installing new software versions on the thin-edge device.</li>
</ul>
<h2 id="extensibility"><a class="header" href="#extensibility">Extensibility</a></h2>
<ul>
<li>Thin-edge should be liberal on the use-cases for an operation plugin.</li>
<li>No constraint on the programming language.</li>
<li>An operation plugin can be provided by thin-edge or a tier party.</li>
</ul>
<h2 id="cloud-specificities"><a class="header" href="#cloud-specificities">Cloud specificities</a></h2>
<ul>
<li>An operation plugin can be cloud specific or not.</li>
<li>Each cloud mapper might need specific supports from the plugins (e.g reporting the operation progress and status).</li>
<li>Each cloud mapper might provide specific supports to the plugins (e.g appropriate bridge topics).</li>
<li>An operation might make sense only on a specific cloud.</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<ul>
<li>Declaring a new operation must be scriptable, notably to be added in installation scripts.</li>
<li>The set of installed operations must persist and last over reboots and power downs.</li>
<li>The device owner can add and remove operations at any time of the device lifecycle,
thin-edge must trigger in the background any necessary registration and initialisation.</li>
<li>Thin-edge should provide a support to enforce the installation constraints,
notably only one plugin should be installed for a given operation for a given cloud.</li>
<li>Some operations may need to be configured.
For example, <code>c8y_LogfileRequest</code> requires additional parameter to be set, <code>log_type</code> in this case.</li>
<li>Some operations may require elevated permissions to be executed (e.g. sudo),
and thin-edge must then provide the mechanisms to run this operation accordingly.</li>
</ul>
<h2 id="discovery"><a class="header" href="#discovery">Discovery</a></h2>
<ul>
<li>Thin-edge should be able to list all the available operations on a device.</li>
<li>Supported operations are to be grouped per supported cloud.</li>
<li>Only one component shall report the set of available operations to the cloud.</li>
</ul>
<h2 id="invocation"><a class="header" href="#invocation">Invocation</a></h2>
<ul>
<li>This is an implementor choice to run an operation plugin as a daemon or on request.</li>
<li>If run as a daemon, it must even be feasible to only declare the operation to thin-edge (on doing so to the cloud),
and to let the daemon managing the entire protocol for that operation.
The typical example here is the <code>c8y-sm</code> mapper which handles the Software Management operations for Cumulocity.</li>
<li>If run on request, one must be able to declare <em>when</em> the operation will be triggered (on which event),
and <em>how</em> (notably with which parameters).</li>
</ul>
<h2 id="cli-support"><a class="header" href="#cli-support">CLI support</a></h2>
<ul>
<li>It would be convenient to manage the set of supported operations using the <code>tedge cli</code> tool.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<ul>
<li>An operation is implemented by an executable that is responsible for:
<ul>
<li>the interactions with the cloud (using the locally bridged MQTT topics),</li>
<li>requesting any required parameters,</li>
<li>reporting the operation progress,</li>
<li>returning any expected results.</li>
</ul>
</li>
<li>On installation, an operation is declared to thin-edge using a configuration file put in an operation directory.
<ul>
<li>This directory is organized in sub-directories per cloud and per operation.</li>
<li>Each operation is represented by a configuration file (using the TOML file format).</li>
<li>
<pre><code class="language-shell">$ ls -l /etc/tegde/operations/c8y
-rw-rw-r-- 1 user user    688 Jan 1 00:01 c8y_LogfileRequest
-rw-rw-r-- 1 user user    331 Jan 1 00:01 c8y_SoftwareUpdate
-rw-rw-r-- 1 user user     40 Jan 1 00:01 c8y_Restart
</code></pre>
</li>
</ul>
</li>
<li>An operation might run independently of thin-edge.
<ul>
<li>In that case, the operation plugin has to run as a daemon (listening for requests)
and ensure that this daemon is enabled of device re-start.</li>
<li>The operation daemon is responsible for triggering the operations.</li>
<li>For thin-edge, the operation just needs to be declared using an empty TOML file. </li>
<li>Thin-edge is only responsible for notifying that the operation is available.</li>
</ul>
</li>
<li>An operation might be executed on request.
<ul>
<li>Thin-edge is then responsible for listening for requests and spawning processes to handle these.</li>
<li>The operation configuration provide the topic and the pattern matching the awaking events.</li>
<li>Which command to run is specified by the plugin configuration file.</li>
<li>Similarly, the configuration file specifies on behalf of which user the plugin command has to be run.</li>
<li>
<pre><code class="language-toml">[exec]
topic = &quot;c8y/s/ds&quot;
on_message = &quot;522,*&quot;
command = &quot;/etc/tedge/plugins/c8y_LogfileRequest&quot;
user = &quot;root&quot;
</code></pre>
</li>
</ul>
</li>
<li>Note that the interpretation of these configuration files is cloud specific.
<ul>
<li>The above examples are Cumulocity specific.
<ul>
<li>See <a href="https://cumulocity.com/guides/device-sdk/mqtt/#subscribe-templates">SmartRest2 operation templates</a> for details.</li>
</ul>
</li>
<li>The <code>c8y</code> mapper needs to know that the file names under <code>/etc/tegde/operations/c8y</code> are Cumulocity operation names
that have to be declared using a <code>114</code> smartRest request.</li>
<li>The <code>c8y</code> mapper needs also to know the <code>c8y_LogfileRequest</code> plugin has to be awaken.</li>
</ul>
</li>
</ul>
<h3 id="to-be-clarified"><a class="header" href="#to-be-clarified">To be clarified</a></h3>
<ul>
<li>Configuration file permissions, what to set, who should be able to change it?</li>
<li>How the set of operations is reloaded after a new operation has been added?</li>
<li>Which component is responsible for executing the operation command for a request?
<ul>
<li>The c8y mapper is definitely the component that has to listen for requests
and to translate operation requests into plugin commands.
But, it would be better to have the agent dealing with command execution and monitoring.
The price to pay is a new indirection level (similar to what is done between the sm-c8y mapper and the agent).</li>
</ul>
</li>
<li>How to pass parameters to the operation?
<ul>
<li>e.g. a remote access operation requires the device to connect to a specific websocket
and it's URL is passed as part of the operation message and needs to be passed to the executing binary.</li>
<li>An option is to pass the whole message from the cloud as the contract implies
that the operation executable will know what to do with it.</li>
</ul>
</li>
<li>We could have regex for the topic/topic+message to match the operation and wake appropriate executor?</li>
<li>Should operations executor be able to accept plain parameters and is it safe? Security considerations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operation-configuration-examples"><a class="header" href="#operation-configuration-examples">Operation Configuration Examples</a></h1>
<p>All operation configuration files use the <code>toml</code> format.</p>
<pre><code class="language-toml">[exec]
  # Exec configuration if the operation requires command execution
  # Required
  command = &quot;echo&quot;
  # Optional
  root = true

[mqtt]
  # MQTT configuration if the operation requires MQTT communication, e.g. forwarding message JSON on the bus
  topic = &quot;tedge/logs&quot;

[extras]
  # Additional configuration if the operation requires additional configuration
  log_type = [&quot;error&quot;]
</code></pre>
<ul>
<li>If the operation doesn't require additional configuration, an empty <code>toml</code> file can be used.</li>
<li>Basic tables names are fixed and are <code>exec</code>, <code>mqtt</code> and <code>extras</code>. Additional tables can be added as needed.</li>
<li>Tables <code>[exec]</code> or <code>[mqtt]</code> must be present if config is not empty.</li>
<li>Tables <code>[exec]</code> and <code>[mqtt]</code> are mutually exclusive and only one of them can be used.</li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example 1</a></h2>
<p>Given operation <code>restart</code>, the operation file would be created in <code>/etc/tegde/operations/c8y</code> with the filename <code>c8y_Restart</code> so the full path would be <code>/etc/tegde/operations/c8y/c8y_Restart</code>.
Assuming <code>restart</code> operation requires no additional parameters as well as can be executed directly in the executor (assume a mapper) no additional configuration is required.</p>
<p>An empty <code>toml</code> file is still valid <code>toml</code> file and can be used to indicate no additional configuration is required.</p>
<p>Given a mapper the flow would be as follows:</p>
<ol>
<li>Mapper reads directory for the cloud which it supports i.e. <code>/etc/tegde/operations/c8y</code>.</li>
<li>Mapper finds the operation file for the operation <code>restart</code> in the directory <code>c8y</code> with filename <code>c8y_Restart</code> which is the only operation.</li>
<li>Mapper takes the filename as operation name and reads the operation file.</li>
<li>Empty operation file means there are no additional configuration parameters and mapper is ready to send supported operations message to c8y which contains the list of supported operations i.e. <code>c8y_Restart</code>.</li>
<li>Cloud operator wants restart the device therefore they send the operation message to the device which mapper interprets as a restart operation and mapper executes restart.</li>
</ol>
<h2 id="example-2-special-case"><a class="header" href="#example-2-special-case">Example 2 (special case)</a></h2>
<p>Given operation <code>c8y_LogfileRequest</code>, the operation file would be created in <code>/etc/tegde/operations/c8y</code> with the filename <code>c8y_LogfileRequest</code> so the full path would be <code>/etc/tegde/operations/c8y/c8y_LogfileRequest</code>.
Operation <code>c8y_LogfileRequest</code> requires additional parameter <code>log_type</code> to be set.</p>
<p>With the operation file the following structure is written:</p>
<pre><code class="language-toml">[exec]

command = &quot;/etc/tedge/plugins/c8y_LogfileRequest&quot;
user = &quot;root&quot;

[init]
topic = &quot;c8y/s/us&quot;
message = &quot;118,error&quot;

[extras]
  # Additional configuration if the operation requires additional configuration
  log_type = [&quot;error&quot;]
</code></pre>
<blockquote>
<p>Alternatives:</p>
<p>Option 1: on init of mapper config will contain a command to be called e.g. sent <code>log_type</code> message to c8y, only the component knows about it (mapper doesn't need to care about it)
Option 2: explicit additional message to be send by the mapper if required/defined using a table in config file e.g. <code>[init]</code> like in the example above.</p>
<p>Done</p>
</blockquote>
<p>Given a mapper the flow would be as follows:</p>
<ol>
<li>Mapper reads directory for the cloud which it supports i.e. <code>/etc/tegde/operations/c8y</code>.</li>
<li>Mapper finds the operation file for the operation <code>c8y_LogfileRequest</code> in the directory <code>c8y</code> with filename <code>c8y_LogfileRequest</code> which is the only operation.</li>
<li>Mapper takes the filename as operation name and reads the operation file.</li>
<li>Operation file contains additional configuration parameters and mapper shall know (i.e. implements) how to interpret the configuration (in this case mapper has to add new fragment to the device type therefore can read the <code>log_type</code> configuration and send new <code>log_type</code> message) ready to send supported operations message to c8y which contains the list of supported operations i.e. <code>c8y_LogfileRequest</code>. E.g. <code>114,c8y_LogfileRequest</code></li>
<li>Cloud operator wants to retrieve logs from the device therefore they send the operation message to the device which mapper interprets as a <code>c8y_LogfileRequest</code> operation and mapper executes <code>c8y_LogfileRequest</code>.</li>
</ol>
<h2 id="example-3"><a class="header" href="#example-3">Example 3</a></h2>
<p>Given an operation which requires communication with another component over the bus e.g. <code>c8y_SoftwareUpdate</code> and no additional configuration is required.</p>
<p>Following operation file could be used:</p>
<pre><code class="language-toml">[mqtt]

request = &quot;tedge/commands/req/software/update&quot;
response = &quot;tedge/commands/res/software/update&quot;
</code></pre>
<ol>
<li>Mapper reads directory for the cloud which it supports i.e. <code>/etc/tegde/operations/c8y</code>.</li>
<li>Mapper finds the operation file for the operation <code>c8y_SoftwareUpdate</code> in the directory <code>c8y</code> with filename <code>c8y_SoftwareUpdate</code> which is the only operation.</li>
<li>Mapper takes the filename as operation name and reads the operation file.</li>
<li>Operation file contains additional configuration parameters and mapper shall know (i.e. implements) how to interpret the configuration (in this case mapper has to forward the request to an executor on the bus) ready to send supported operations message to c8y which contains the list of supported operations i.e. <code>c8y_SoftwareUpdate</code>. E.g. <code>114,c8y_SoftwareList</code></li>
<li>From this point mapper should subscribe to the provided response topic: <code>tedge/commands/res/software/update</code>.</li>
<li>From this point whenever mapper receives a request for the operation <code>c8y_SoftwareUpdate</code> it shall forward the request to the executor on the bus on provided topic: <code>tedge/commands/req/software/update</code> and would expect a response on the provided topic: <code>tedge/commands/res/software/update</code>.</li>
<li>Cloud operator wants to update software on the device therefore they send the operation message to the device which mapper interprets as a <code>c8y_SoftwareUpdate</code> operation and mapper forwards the operation request to an executor (in this case the agent) on provided topic <code>tedge/commands/req/software/update</code>.</li>
<li>Executor processes the request and sends a response on provided topic <code>tedge/commands/res/software/update</code>.</li>
<li>Mapper translates the response to the cloud format and sends it to the cloud.</li>
</ol>
<h2 id="example-4"><a class="header" href="#example-4">Example 4</a></h2>
<p>Given multiple operation files in operations directory and disregarding additional configuration following operations have been registered: <code>c8y_LogfileRequest</code>, <code>c8y_SoftwareUpdate</code>, <code>c8y_Restart</code>.
Directory content:</p>
<pre><code class="language-shell">$ ls -l /etc/tegde/operations/c8y
-rw-rw-r-- 1 user user    688 Jan 1 00:01 c8y_LogfileRequest
-rw-rw-r-- 1 user user    331 Jan 1 00:01 c8y_SoftwareUpdate
-rw-rw-r-- 1 user user     40 Jan 1 00:01 c8y_Restart
</code></pre>
<ol>
<li>Mapper reads directory for the cloud which it supports i.e. <code>/etc/tegde/operations/c8y</code>.</li>
<li>Mapper finds the operation files in the directory <code>c8y</code>.</li>
<li>Mapper takes the filenames of all the files in this directory and reads the operation file.</li>
<li>Mapper collates the list of supported operations and when it's ready sends supported operations message to c8y which contains the list of supported operations i.e. <code>c8y_LogfileRequest</code>, <code>c8y_SoftwareUpdate</code>, <code>c8y_Restart</code>. E.g. <code>114,c8y_LogfileRequest,c8y_SoftwareUpdate,c8y_Restart</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edgeio-tooling-for-operations-management"><a class="header" href="#thin-edgeio-tooling-for-operations-management"><code>thin-edge.io</code> tooling for operations management</a></h1>
<p><code>thin-edge.io</code> provides cli tool for operations management.</p>
<ul>
<li>use <code>tedge cli</code> command to add or remove operations one by one, list all operations, list all operations per cloud
<ul>
<li>use new tedge subcommand <code>tedge operations</code></li>
<li><code>tedge operations</code> supports following operations:
<ul>
<li><code>add cloud_name operation_name [--config configuration_filepath]</code> - adds single operation to the list if doesn't exist</li>
<li><code>remove cloud_name operation_name</code> - removes single operation from the list if exists</li>
<li><code>list [cloud_name]</code> - lists all operations, unless specific cloud table name provided, then lists only operations for the cloud if exists</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>e.g.:</p>
<ul>
<li>
<p><code>tedge operations add c8y c8y_Restart</code></p>
</li>
<li>
<p><code>tedge operations add c8y c8y_LogfileRequest --config ./logfile_config</code></p>
</li>
<li>
<p>Future extension should provide a tool to create operations files - OUT OF SCOPE.</p>
</li>
<li>
<p>Some configuration templates are going to be provided in the <code>thin-edge.io</code> repository.</p>
</li>
</ul>
<p>Naming and details subject to change and comments.</p>
<h2 id="use-in-tedge-components"><a class="header" href="#use-in-tedge-components">Use in tedge components</a></h2>
<p><code>thin-edge.io</code> mappers should pickup operations per cloud from operations repository (filesystem),
but an executor like agent to should be provided to execute them (e.g. permissions or state control).
This way the executor can be configured to use different operations for different components.</p>
<h2 id="adding-supported-operations"><a class="header" href="#adding-supported-operations">Adding supported operations</a></h2>
<h3 id="adding-supported-operations-remotely"><a class="header" href="#adding-supported-operations-remotely">Adding supported operations remotely</a></h3>
<p>Using <code>tedge cli</code> to add supported operations allows any tedge components (or even any device system component) to extend the list of supported operations on demand.</p>
<p><code>tedge cli</code> tool can be scripted and therefore when installing new components using thin-edge.io software management supported operations can be added as a part of installation script (e.g. for apt/deb <code>postinst</code> script may execute necessary steps), or if it is a custom plugin supporting other package the finalize phase could invoke some metadata/postinstall script in the <code>finalize</code> phase.</p>
<pre><code class="language-shell">#!/bin/sh

set -e

tedge operations add c8y c8y_Apama
tedge operations add c8y c8y_BatchAnalytics --config ./batch_analytics_config
</code></pre>
<blockquote>
<p>Note: In cases when tedge cli is not installed (currently not an option) one can use direct file modification to add or remove supported operations.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>That document specifies the feature &quot;Software Management&quot; in scope of thin-edge.</p>
<p>In thin-edge &quot;Software Management&quot; functionality basically results from given Cumulocity's &quot;Software Management&quot; feature. Anyway thin-edge's &quot;Software Management&quot; concept shall be flexible and open for potential other upcoming Clouds (e.g. Azure).</p>
<p>The diagram below indentifies all relevant use-cases for thin-edge. Thereby each use-case represents a functionality and each will be detailed in a further (linked) sub-specifications.</p>
<p>Some further explanation about diagrams elements it's interpretation could be found below the diagram.</p>
<p><img src="software-management/images/use-cases-sw-management.svg" alt="Use Case Diagram" /></p>
<h1 id="actors"><a class="header" href="#actors">Actors</a></h1>
<p>In the middle of the diagram <strong>thin-edge + mosquitto</strong> are visible as system. To reduce complexity both are considered here as one black box. </p>
<p>At right side actor <strong>Cloud</strong> represents Cumulocity or another potential cloud.</p>
<p>At left side multiple <strong>Package-Manager</strong> actors are placed. A Package-Manager is a SW component that supportes to install or remove SW packages on the Device (e.g. Debian's &quot;APT&quot;, Canonical's &quot;Snap&quot; or Red Hat’s “RPM”). Thin-edge &quot;SW Management&quot; concept requires that one or more Package-Managers are provided by the Device's SW system.</p>
<p>Finally on left side actors <strong>FW (Firmware)-Manager</strong> and <strong>Config-Manager</strong> are denoted. Both are shown here to point out that for now Firmware and Configuration are out of scope of that specification. Note that in the diagram both have no connection to any relevant use-case. </p>
<h1 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h1>
<p>All use-case above are prefixed with a unique identified (as UC&lt;i&gt;), just for easier referencing.</p>
<table><thead><tr><th>UC1:</th><th>&quot;Report SW List&quot;</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>The device reports a list of current installed SW packages to the cloud. Therefore all Package-Managers are involved.</td></tr>
<tr><td><strong>Trigger</strong></td><td><strong>TO-BE-DECIDED-#1:</strong> Just on Device/Agent start? Or somehow periodically? (Last might capture also manually installed packages). For taking decicision see also &quot;Software Management Study&quot; in archbee: https://app.archbee.io/docs/9iGX1hbDjwAeMfyO9A3YE/coxr9CuTWSjk0eE1Nzgoj <br/>-&gt; There check section &quot;Update Profile Operation&quot; and search for &quot;periodically&quot;.</td></tr>
<tr><td> </td><td>TODO: add link to more details about that use-case.</td></tr>
</tbody></table>
<p> 
 
 
 
 
 </p>
<table><thead><tr><th>UC2:</th><th>&quot;Update SW List&quot;</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Installing or removing one or more SW packages on the device.</td></tr>
<tr><td><strong>Trigger</strong></td><td>Request coming from cloud.</td></tr>
<tr><td> </td><td>Detailed spec for that use-case is here: <a href="software-management//src/software-management/usecase-update-swlist.html">src/software-management/usecase-update-swlist.md</a></td></tr>
</tbody></table>
<p> 
 
 
 
 
 </p>
<table><thead><tr><th>UC3:</th><th>&quot;Sync SW List&quot;</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Sync Software List of Cumulocity. In Cumulocity it has been deprecated in favour of &quot;Update Software&quot;.<br/> For now that use-case is out of scope for thin-edge.<br/> See also &quot;Cumulocity Use Case: Sync Software List&quot; in archbee: https://app.archbee.io/docs/9iGX1hbDjwAeMfyO9A3YE/UuDcppPEYlD9alaF7y_e7</td></tr>
<tr><td><strong>Trigger</strong></td><td></td></tr>
</tbody></table>
<p> 
 
 
 
 
 </p>
<table><thead><tr><th>UC4:</th><th>&quot;Update Profile&quot;</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Update Profile Operation of Cumulocity. A profile contains beside a SW list also a desired Firmware and Configuration.<br/> Firmware-Management and Coniguration-Management are planned later for thin-edge, so that use-case is currently not relevant.</td></tr>
<tr><td><strong>Trigger</strong></td><td></td></tr>
</tbody></table>
<p> 
 
 
 
 
 </p>
<table><thead><tr><th>UC5:</th><th>&quot;Install/Remove SW Package&quot;</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>Installs or removes one or more SW packages on the Device. Therefore the Package-Manager that manages the relevant package is involved.</td></tr>
<tr><td><strong>Trigger</strong></td><td>UC2 (&quot;Update SW List&quot;)</td></tr>
<tr><td> </td><td>Detailed spec for that use-case is here (same as for UC2): <a href="software-management//src/software-management/usecase-update-swlist.html">src/software-management/usecase-update-swlist.md</a></td></tr>
</tbody></table>
<h1 id="open-topcis"><a class="header" href="#open-topcis">Open Topcis</a></h1>
<p>(1) Open Decision about trigger of &quot;Report SW List&quot;. See &quot;TO-BE-DECIDED-#1&quot; above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>That document specifies the &quot;Software Management&quot; use-case &quot;Update SW List&quot;. 
The purpose of the use-case is to install new software or removing existing from
Cloud side on the device.
For more information about the context and other use-cases see &quot;Software 
Management&quot; use-case specification in: <a href="software-management//src/software-management/README.html">src/software-management/README.md</a></p>
<p>The sequence diagram below indentifies all involved components as well as all 
message flows between those. Thereby the components are represented as objects,
starting from the very right side with the actor &quot;Cloud&quot; reaching to the very left side with the
actor &quot;Package Manager&quot;. Further details (if any) are defined in linked 
sub-specifications.</p>
<p>Further explanations about diagram's elements or it's interpretation could be found below the diagram.</p>
<p><img src="software-management/images/uc-update-swlist.svg" alt="Sequence Diagram Update SW-list" /></p>
<h1 id="components"><a class="header" href="#components">Components</a></h1>
<table><thead><tr><th>Name</th><th>&quot;Cloud&quot;</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>The cloud triggers the &quot;update swlist&quot; operation, and finally receives it's result. The trigger request contains the sw-list to the Cloud mapper on the device.</td></tr>
<tr><td><strong>Sequence</strong></td><td>(1) The Cloud sends a request to start an update to the Cloud mapper on the device. The request contains the sw-list.</td></tr>
<tr><td> </td><td>(2) The cloud gets feedback from Cloud mapper (status &quot;executing&quot;) when update was started.</td></tr>
<tr><td> </td><td>(3) The cloud gets feedback from Cloud mapper (status &quot;successful&quot;) when update was sucessfully processed.</td></tr>
<tr><td> </td><td> </td></tr>
<tr><td><strong>Further Spec</strong></td><td>Spec about details of interface between Cloud and Cloud Mapper is under construction. See <a href="https://cumulocity.atlassian.net/browse/CIT-439">Ticket CIT-439</a></td></tr>
</tbody></table>
<p> 
 
 
 
 
 </p>
<table><thead><tr><th>Name</th><th>&quot;Cloud mapper&quot;</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>The Cloud mapper abstracts the specific Cloud to the SM agent. For each Cloud a specific &quot;Cloud-mapper&quot; might required to be implemented. In that spec the Cloud mapper for Cumulocity is outlined.</td></tr>
<tr><td><strong>Sequence</strong></td><td>(1) When the Cloud mapper receives an update request from Cloud it forwards the request to the SM agent. If the sw-list contained in the Cloud request does not match the SM agent's interface translation has to be done by the Cloud mapper.</td></tr>
<tr><td> </td><td>(2) SM agent sends feedback to cloud (status &quot;executing&quot;).</td></tr>
<tr><td> </td><td> </td></tr>
<tr><td><strong>Further Spec</strong></td><td>Spec about details of interface between Cloud Mapper and SM Agent is under construction. See <a href="https://cumulocity.atlassian.net/browse/CIT-411">Ticket CIT-411</a></td></tr>
</tbody></table>
<p> 
 
 
 
 
 </p>
<table><thead><tr><th>Name</th><th>&quot;SM agent&quot;</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>The SM agent is the core component in thin-edge that manages the Software Management functionality.</td></tr>
<tr><td><strong>Sequence</strong></td><td>(1) On incoming update request from the Cloud mapper the prepare command is sent to all Package Manager Plugins.</td></tr>
<tr><td> </td><td>(2) The SM agent splits sw-list into separate lists per package-type (e.g. &quot;sw-list_pkgType1&quot;, &quot;sw-list_pkgType2&quot;, ...).</td></tr>
<tr><td> </td><td>(3) The command exec-list is sent with list &quot;sw-list_pktType1&quot; as argument to the Package Manager Plugin for package-type 1. That command allows the plugin to handle the whole list in one command. On the other side the plugin is free to just return &lt;not-implemeneted&gt; and instead use a 2nd option provided by agent. The 2nd Option feeds plugin package-by-package, that is more simple but less flexible. Therefore follow next step below.</td></tr>
<tr><td> </td><td>(4) If exec-list has return &lt;not-implemeneted&gt; agent iterates over &quot;sw-list_pktType1&quot;. For each particular package the command (&quot;install&quot; or &quot;remove&quot;) is send to responsible Package Manager Plugin. The according &quot;command&quot; is determined based on information that is part of the sw-list for each package.</td></tr>
<tr><td> </td><td>Same steps (3 and 4 from above) will be executed for each splitted list &quot;sw-list_pktType&lt;i&gt;&quot; and according Package Manager Plugin.</td></tr>
<tr><td> </td><td><strong>TO-BE-DECIDED-#1:</strong> Some delta comparision shall occur at some place, to avoid installing already installed packages and avoid removing not existing ones. To be decided whether delta-comparision shall occur in SM Agent or Package Manager Plugin. (?) <br/><br/></td></tr>
<tr><td></td><td></td></tr>
<tr><td> </td><td> </td></tr>
<tr><td><strong>Further Spec</strong></td><td>Spec about details of SM Agent and it's interface to Cloud Mapper is under construction. See <a href="https://cumulocity.atlassian.net/browse/CIT-411">Ticket CIT-411</a> <br/>Spec about interface between SM agent and Package Manager Plugin see <a href="https://github.com/thin-edge/thin-edge.io-specs/blob/main/src/software-management/plugin-api.md">src/software-management/plugin-api.md</a></td></tr>
</tbody></table>
<p> 
 
 
 
 
 </p>
<table><thead><tr><th>Name</th><th>Package Manager Plugin</th></tr></thead><tbody>
<tr><td><strong>Purpose</strong></td><td>To abstract the device specific Package Manager (e.g. Debian's &quot;APT&quot;, Canonical's &quot;Snap&quot; or Red Hat’s “RPM”).</td></tr>
<tr><td><strong>Sequence</strong></td><td>(1) Receives prepare command from SM agent to do some prepare action, if any.</td></tr>
<tr><td> </td><td>(2) Receives command &quot;exec-list&quot; including sw-list with all packages for according package-type. The sw-list contains also operations per each package as contained in orignial sw-list from Cloud. The Package Manager Plugin can use that sw-list to instruct the according Package Manager in a specific order to reach intented software configuration. If the order is not relevant for the specific Package Manager the Package Manager Plugin is free to return &lt;not-implemented&gt; here. Then SM agent will feed the plugin package-by-package (see next step below), that might allow a much more simple plugin implementation.</td></tr>
<tr><td> </td><td>NOTE: For more Details (e.g. about reason for feeding with one list vs. feeding package-by-package) and how to encode &lt;not-implemented&gt; see Package Manager Plugin specififaction referenced below. PLEASE NOTE: Details &quot;feeding with one list&quot; are not yet part of the Package Manager Plugin specififaction, but will be added soon.</td></tr>
<tr><td> </td><td>(3) If plugin has return &lt;not-implemented&gt; in step 2 above, plugin receives package-by-package command install or removed including Package name from SM agent, and instructs according Package Manager to do so.</td></tr>
<tr><td> </td><td>(4) Receives finalize command from SM agent to do some finish action, if any.</td></tr>
<tr><td> </td><td> </td></tr>
<tr><td><strong>Further Spec</strong></td><td>Spec about interface between SM agent and Package Manager Plugin see <a href="https://github.com/thin-edge/thin-edge.io-specs/blob/main/src/software-management/plugin-api.md">src/software-management/plugin-api.md</a></td></tr>
</tbody></table>
<h1 id="open-topcis-1"><a class="header" href="#open-topcis-1">Open Topcis</a></h1>
<p>(1) All unhappy paths missing. Need to be specified.</p>
<p>(2) Open Decision about delta-comparision between current sw-list and sw-list. See &quot;TO-BE-DECIDED-#1&quot; above.</p>
<p>(3) Open Decision about stable order in SW-list. See &quot;TO-BE-DECIDED-#2&quot; above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-manager-plugin-api"><a class="header" href="#package-manager-plugin-api">Package Manager Plugin API</a></h1>
<p>Thin-edge uses plugins to delegate to the appropriate package managers and installers
all the software management operations: installation of packages, uninstallations and queries.</p>
<ul>
<li>A package manager plugin acts as a facade for a specific package manager.</li>
<li>A plugin is an executable that follows the <a href="software-management/./#plugin-api">plugin API</a>.</li>
<li>On a device, several plugins can be installed to deal with different kinds of software modules.</li>
<li>The filename of a plugin is used by thin-edge to determine the appropriate plugin for a software module.</li>
<li>All the actions on a software module are directed to the plugin bearing the name that matches the module type name.</li>
<li>The plugins are loaded and invoked by the sm-agent in a systematic order (in practice the alphanumerical order of their names in the file system).</li>
<li>The software modules to be installed/removed are also passed to the plugins in a consistent order.</li>
<li>Among all the plugins, one can be marked as the default plugin using <code>tedge config</code> cli.</li>
<li>The default plugin is invoked when an incoming software module in the cloud request doesn't contain any explicit type annotation.</li>
<li>Several plugins can co-exist for a given package manager as long as they are given different names.
Each can implement a specific software management policy.
For instance, for a debian package manager, several plugins can concurrently be installed, say one named <code>apt</code> to handle regular packages from the public apt repository and another named <code>company-apt</code> to install packages from a company's private package repository.</li>
</ul>
<h2 id="plugin-repository"><a class="header" href="#plugin-repository">Plugin repository</a></h2>
<ul>
<li>To be used by thin-edge, a plugin has to stored in the directory <code>/etc/tedge/sm-plugins</code>.</li>
<li>A plugin must be named after the software module type as specified in the cloud request.
That is, a plugin named <code>apt</code> handles software modules that are defined with type <code>apt</code> in the cloud request.
Consequently a plugin to handle software module defined for <code>docker</code> must be named <code>docker</code>.</li>
<li>The same plugin can be given different names, using virtual links.</li>
<li>When there are multiple plugins on a device, one can be marked as the default plugin using the command
<code>tedge config set software.plugin.default &lt;plugin-name&gt;</code></li>
<li>If there's one and only one plugin available on a device, that's treated as the default, even without an explicit configuration.</li>
</ul>
<p>On start-up and sighup, the sm-agent registers the plugins as follow:</p>
<ol>
<li>Iterate over the executable file of the directory <code>/etc/tedge/sm-plugins</code>.</li>
<li>Check the executable is indeed a plugin, calling the <a href="software-management/./#the_list_command"><code>list</code></a> command.</li>
</ol>
<h2 id="plugin-api"><a class="header" href="#plugin-api">Plugin API</a></h2>
<ul>
<li>A plugin must implement all the commands used by the sm-agent of thin-edge,
and support all the options for these commands.</li>
<li>A plugin should not support extra command or option.</li>
<li>A plugin might have a configuration file.
<ul>
<li>It can be a list of remote repositories, or a list of software modules to be excluded.</li>
<li>These configuration files can be managed from the cloud via the sm-agent (TODO: how).</li>
</ul>
</li>
</ul>
<h3 id="input-output-and-errors"><a class="header" href="#input-output-and-errors">Input, Output and Errors</a></h3>
<ul>
<li>The plugins are called by the sm-agent using a child process for each action.</li>
<li>Beside command <code>update-list</code> there is no input beyond the command arguments, and a plugin that does not 
implement <code>update-list</code> can close its <code>stdin</code>.</li>
<li>The <code>stdout</code> and <code>stderr</code> of the process running a plugin command are captured by the sm-agent.
<ul>
<li>These streams don't have to be the streams returned by the underlying package manager.
It can be a one sentence summary of the error, redirecting the administrator to the package manager logs.</li>
</ul>
</li>
<li>A plugin must return the appropriate exit status after each command.
<ul>
<li>In no cases, the error status of the underlying package manager should be reported.</li>
</ul>
</li>
<li>The exit status are interpreted by sm-agent as follows:
<ul>
<li><strong><code>0</code></strong>: success.</li>
<li><strong><code>1</code></strong>: usage. The command arguments cannot be interpreted, and the command has not been launched.</li>
<li><strong><code>2</code></strong>: failure. The command failed and there is no point to retry.</li>
<li><strong><code>3</code></strong>: retry. The command failed but might be successful later (for instance, when the network will be back).</li>
</ul>
</li>
<li>If the command fails to return within 5 minutes, the sm-agent reports a timeout error:
<ul>
<li><strong><code>4</code></strong>: timeout.</li>
</ul>
</li>
</ul>
<h3 id="the-list-command"><a class="header" href="#the-list-command">The <code>list</code> command</a></h3>
<p>When called with the <code>list</code> command, a plugin returns the list of software modules that have been installed with this plugin.</p>
<pre><code class="language-shell">$ debian-plugin list
...
{&quot;name&quot;:&quot;collectd-core&quot;,&quot;version&quot;:&quot;5.8.1-1.3&quot;}
{&quot;name&quot;:&quot;mosquitto&quot;,&quot;version&quot;:&quot;1.5.7-1+deb10u1&quot;}
...
</code></pre>
<p>Contract:</p>
<ul>
<li>This command take no arguments.</li>
<li>If an error status is returned, the executable is removed from the list of plugins.</li>
<li>The list is returned using the <a href="https://jsonlines.org/">jsonlines</a> format.
<ul>
<li><strong><code>name</code></strong>: the name of the module. This name is the name that has been used to install it and that need to be used to remove it.</li>
<li><strong><code>version</code></strong>: the version currently installed. This is a string that can only been interpreted in the context of the plugin.</li>
</ul>
</li>
</ul>
<h3 id="the-prepare-command"><a class="header" href="#the-prepare-command">The <code>prepare</code> command</a></h3>
<p>The <code>prepare</code> command is invoked by the sm-agent before a sequence of install and remove commands</p>
<pre><code>$ /etc/tedge/sm-plugins/debian prepare
$ /etc/tedge/sm-plugins/debian install x
$ /etc/tedge/sm-plugins/debian install y
$ /etc/tedge/sm-plugins/debian remove z
$ /etc/tedge/sm-plugins/debian finalize
</code></pre>
<p>For many plugins this command will do nothing. However, It gives an opportunity to the plugin to:</p>
<ul>
<li>Update the dependencies before an operation, *i.e. a sequence of actions.
Notably, a debian plugin can update the <code>apt</code> cache issuing an <code>apt-get update</code>.</li>
<li>Start a transaction, in case the plugin is able to manage rollbacks.</li>
</ul>
<p>Contract:</p>
<ul>
<li>This command take no arguments.</li>
<li>No output is expected.</li>
<li>If the <code>prepare</code> command fails, then the planned sequences of actions (.i.e the whole sm operation) is cancelled. </li>
</ul>
<h3 id="the-finalize-command"><a class="header" href="#the-finalize-command">The <code>finalize</code> command</a></h3>
<p>The <code>finalize</code> command closes a sequence of install and remove commands started by a <code>prepare</code> command.</p>
<p>This can be a no-op, but this is also an opportunity to:</p>
<ul>
<li>Remove any unnecessary software module after a sequence of actions.</li>
<li>Commit or rollback the sequence of actions.</li>
<li>Restart any processes using the modules, e.g. restart the analytics engines if the modules have changed</li>
</ul>
<p>Contract:</p>
<ul>
<li>This command take no arguments.</li>
<li>No output is expected.</li>
<li>This command might check (but doesn't have to) that the list of install and remove command has been consistent.
<ul>
<li>For instance, a plugin might raise an error after the sequence <code>prepare;install a; remove a-dependency; finalize</code>.</li>
</ul>
</li>
<li>If the <code>finalize</code> command fails, then the planned sequences of actions (.i.e the whole sm operation) is reported as failed,
even if all the atomic actions has been successfully completed.</li>
</ul>
<h3 id="the-install-command"><a class="header" href="#the-install-command">The <code>install</code> command</a></h3>
<p>The <code>install</code> command installs a software module, possibly of some expected version.</p>
<pre><code>$ plugin install NAME [--version VERSION] [--file FILE]
</code></pre>
<p>Contract:</p>
<ul>
<li>The command requires a single mandatory argument: the software module name.
<ul>
<li>This module name is meaningful only to the plugin.</li>
</ul>
</li>
<li>An optional version string can be provided.
<ul>
<li>This version string is meaningful only to the plugin
and is transmitted unchanged from the cloud to the plugin.</li>
<li>The version string can include constraints (as at least that version),
from the sm-agent viewpoint this is no more than a string.</li>
<li>If no version is provided the plugin is free to install the more appropriate version.</li>
</ul>
</li>
<li>An optional file path can be provided.
<ul>
<li>When the device administrator provides an url,
the sm-agent downloads the software module on the device,
then invoke the install command with a path to that file.</li>
<li>If no file is provided, the plugin has to derive the appropriate location from its repository
and to download the software module accordingly.</li>
</ul>
</li>
<li>The command installs the requested software module and any dependencies that might be required.
<ul>
<li>It is up to the plugin to define if this command triggers an installation or an upgrade.
It depends on the presence of a previous version on the device and
of the ability of the package manager to deal with concurrent versions for a module. </li>
<li>A plugin might not be able to install dependencies.
In that case, the device administrator will have to request explicitly the dependencies to be installed first.</li>
<li>After a successful sequence <code>prepare; install foo; finalize</code> the module <code>foo</code> must be reported by the <code>list</code> command. </li>
<li>After a successful sequence <code>prepare; install foo --version v; finalize</code> the module <code>foo</code> must be reported by the <code>list</code> command with the version <code>v</code>.
If the plugin manage concurrent versions, the module <code>foo</code> might also be reported with versions already installed before the operation.</li>
<li>A plugin is not required to detect inconsistent actions as <code>prepare; install a; remove a-dependency; finalize</code>.</li>
<li>This is not an error to run this command twice or when the module is already installed.</li>
</ul>
</li>
<li>An error must be reported if:
<ul>
<li>The module name is unknown.</li>
<li>There is no version for the module that matches the constraint provided by the <code>--version</code> option.</li>
<li>The file content provided by <code>--file</code> option:
<ul>
<li>is not in the expected format,</li>
<li>doesn't correspond to the software module name,</li>
<li>has a version that doesn't match the constraint provided by the <code>--version</code> option (if any).</li>
</ul>
</li>
<li>The module cannot be downloaded.</li>
<li>The module cannot be installed.</li>
</ul>
</li>
</ul>
<h3 id="the-remove-command"><a class="header" href="#the-remove-command">The <code>remove</code> command</a></h3>
<p>The <code>remove</code> command uninstalls a software module, and possibly its dependencies if no other modules are dependent on those.</p>
<pre><code>$ plugin remove NAME [--version VERSION]
</code></pre>
<p>Contract:</p>
<ul>
<li>The command requires a single mandatory argument: the module name.
<ul>
<li>This module name is meaningful only to the plugin
and is transmitted unchanged from the cloud to the plugin.</li>
</ul>
</li>
<li>An optional version string can be provided.
<ul>
<li>This version string is meaningful only to the plugin
and is transmitted unchanged from the cloud to the plugin.</li>
</ul>
</li>
<li>The command uninstall the requested module and possibly any dependencies that are no more required.
<ul>
<li>If a version is provided, only the module of that version is removed.
This is in-practice useful only for a package manager that is able to install concurrent versions of a module.</li>
<li>After a successful sequence <code>prepare; remove foo; finalize</code> the module <code>foo</code> must no more be reported by the <code>list</code> command. </li>
<li>After a successful sequence <code>prepare; remove foo --version v; finalize</code> the module <code>foo</code> no more be reported by the <code>list</code> command with the version <code>v</code>.
If the plugin manage concurrent versions, the module <code>foo</code> might still be reported with versions already installed before the operation.</li>
<li>A plugin is not required to detect inconsistent actions as <code>prepare; remove a; install a-reverse-dependency; finalize</code>.</li>
<li>This is not an error to run this command twice or when the module is not installed.</li>
</ul>
</li>
<li>An error must be reported if:
<ul>
<li>The module name is unknown.</li>
<li>The module cannot be uninstalled.</li>
</ul>
</li>
</ul>
<h3 id="the-update-list-command"><a class="header" href="#the-update-list-command">The <code>update-list</code> command</a></h3>
<p>The <code>update-list</code> command accepts a list of software modules and associated operations as <code>install</code> or <code>remove</code>.</p>
<p>This basically achieves same purpose as original commands <code>install</code> and <code>remove</code>, but gets passed all software modules to be processed in one command.
This can be needed when order of processing software modules is relevant - e.g. when dependencies between packages inside the software list do occur.</p>
<pre><code># building list of software modules and operations, 
# and passing to plugin's stdin via pipe:

$ echo '\
install &quot;name1&quot; &quot;version1&quot; &quot;path1&quot;
install &quot;name2&quot; &quot;version2&quot; &quot;&quot;
remove  &quot;name3&quot; &quot;version3&quot;
remove  &quot;some name with spaces&quot; &quot;&quot;' \
 | plugin update-list
</code></pre>
<p>Contract:</p>
<ul>
<li>This command is optional for a plugin. It can be implemented alternatively to original commands <code>install</code> and <code>remove</code> as both are specified above.
<ul>
<li>If a plugin does not implement this command it must return exit status <code>1</code>. In that case sm-agent will call the plugin again 
package-by-package using original commands <code>install</code> and <code>remove</code>.</li>
<li>If a plugin implements this command sm-agent uses it instead of original commands <code>install</code> and <code>remove</code>.</li>
</ul>
</li>
<li>This command takes no commandline arguments, but expects a software list sent from sm-agent to plugin's <code>stdin</code>.</li>
<li>In the software list each software module is represented by exactly one line. That line is formatted as a usual shell commandline argument list.</li>
<li>Each of a software module's commandline argument list is treated as shell does, i.E. quotes and escapes can be used.</li>
<li>The position of each argument in the argument list has it's defined meaning:
<ul>
<li>1st argument: Is the operation and can be <code>install</code> or <code>remove</code> </li>
<li>2nd argument: Is the software module's name.</li>
<li>3rd argument: Is the software module's version. That argument is optional and can be empty (then empty string &quot;&quot; is used).</li>
<li>4th argument: Is the software module's path. That argument is optional and can be empty (then empty string &quot;&quot; is used). For operation <code>remove</code> that argument does not exist.</li>
</ul>
</li>
<li>Behaviour of operations <code>install</code> and <code>remove</code> is same as for original commands <code>install</code> and <code>remove</code> as specified above.
<ul>
<li>For details about operations' arguments &quot;name&quot;, &quot;version&quot; and &quot;path&quot;, see specification of original command <code>install</code> or <code>remove</code>.</li>
<li>For details about <code>exitstatus</code> see accoring specification of original command <code>install</code> or <code>remove</code>. </li>
</ul>
</li>
<li>An overall error must be reported (via process's exit status) when at least one software module operation has failed.</li>
</ul>
<p>Example how to invoke that plugin command <code>update-list</code>:</p>
<pre><code>$ plugin update-list &lt;&lt;EOF
install name1 version1
install name2 &quot;&quot; path2
remove &quot;name 3&quot; version3
remove name4
EOF
</code></pre>
<p>That is equivalent to use of original commands (<code>install</code> and <code>remove</code>):</p>
<pre><code>$ plugin install name1 --module-version version1
$ plugin install name2 --module-path path2
$ plugin remove &quot;name 3&quot; --module-version version3
$ plugin remove name4
</code></pre>
<p>Exemplary implementation of a shell script for parsing software list from <code>stdin</code>:</p>
<pre><code>#!/bin/sh

read_module() {
    if [ $# -lt 3 ]
    then
      echo &quot;Missing version or path for sw-module '${1}'&quot;
    else
      mOperation=${1}
      shift
      mName=${1}
      shift
      mVersion=${1}
      shift
      mPath=${1}
      shift
      echo &quot;$mOperation, $mName, $mVersion, $mPath&quot;
    fi
}

echo &quot;&quot;
echo &quot;---+++ reading software list +++---&quot;
while read -r line;
do
  # convert line to command-line argument array
  eval &quot;moduleArray=($line)&quot;;
  read_module &quot;${moduleArray[@]}&quot;
done
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-management-agent"><a class="header" href="#software-management-agent">Software Management Agent</a></h1>
<p>The software management agent (referred to as <code>SM Agent</code> in the rest of this document) is the component that's responsible for the software management operations on a Thin Edge device.
It primarily interacts with a <code>Cloud Mapper</code> and one or more <code>Software Plugins</code> backed by a software package manager (apt, snap, docker etc).</p>
<p>The <code>Cloud Mapper</code> is the process that's responsible for discovering the capabilities of the device and reporting that to the cloud, cloud message mapping as well as any other cloud-specific processing logic.
The cloud mapper's behaviour handling of software management requests/response are describe in detail here <a href="software-management/./c8y-mapper-operation-handling.html">c8y-mapper-operation-handling.md</a></p>
<p>The <code>Software Plugin</code> handles the installation/removal of software modules with the help of package manager, when called by the <code>SM Agent</code>.
The software plugin specification is captured in detail here <a href="software-management/./plugin-api.html">./plugin-api.md</a></p>
<h1 id="sm-agent-startup"><a class="header" href="#sm-agent-startup">SM Agent Startup</a></h1>
<p>The sequence of operations and message exchanges happening on every startup of the sm-agent (initial startup on <code>tedge connect</code>, service restart, device restarts etc).</p>
<pre class="mermaid">sequenceDiagram
    participant Software Plugin
    participant SM Agent
    participant Cloud Mapper
    alt If a SoftwareUpdateOperation was in-progress as found in persistence store
        SM Agent-&gt;&gt;Cloud Mapper: SoftwareUpdateOperation FAILED
        SM Agent--&gt;&gt;SM Agent: Clear SoftwareUpdateOperation in-progress flag from persistence store
    end

    alt If any software plugins available on the device
        SM Agent-&gt;&gt;Cloud Mapper: Declare SoftwareList+SoftwareUpdate capabilities
    end

    alt If any SoftwareUpdateOperation is PENDING
        Cloud Mapper--&gt;&gt;SM Agent: SoftwareUpdateOperation
    end

</pre>
<p>On every startup, sm-agent checks if a <code>SoftwareUpdateOperation</code> was in progress before the startup, from its persistent store.
If yes, it means that the sm-agent crashed or the device/service got restarted while the update operation was in-progress.
As long as we don't support resumption of software update operations, it's better to just mark the last operation failed so that the users can retry the update operation.</p>
<p>For now, persisting some information that the <code>SoftwareUpdateOperation</code> is in-progress is sufficient.
Once we start supporting software update resumption after crashes/restarts, the entire software update list itself will have to be persisted and updated as the operation is being processed.</p>
<p>On startup, the agent also declares its capabilities to the <code>Cloud Mapper</code> so that the cloud mapper communicate the same to the cloud.
One receipt of this capability announcement message, the mapper will respond back with the oldest PENDING operation for that capability, if any are queued on the cloud.</p>
<h1 id="sm-agent-runtime"><a class="header" href="#sm-agent-runtime">SM Agent Runtime</a></h1>
<p>The SM Agent needs to handle two kinds of requests from the cloud: software list request and software update request.</p>
<p>The sequence of operations on the receipt of a software list request is as follows:</p>
<pre class="mermaid">sequenceDiagram
    participant Software Plugin
    participant SM Agent
    participant Cloud Mapper
    Cloud Mapper--&gt;&gt;SM Agent: SoftwareListRequest
    SM Agent -&gt;&gt; Cloud Mapper: Status executing
    loop Each Plugin
        SM Agent-&gt;&gt;Software Plugin: plugin-cmd list
        Software Plugin--&gt;&gt;SM Agent: list cmd output
    end
    SM Agent-&gt;&gt;Cloud Mapper: SoftwareListResponse
</pre>
<p>The sequence of operations on the receipt of a software update request is as follows:</p>
<pre class="mermaid">sequenceDiagram
    participant Software Plugin
    participant SM Agent
    participant Cloud Mapper

    alt if a SoftwareUpdateOperation is PENDING
        Cloud Mapper--&gt;&gt;SM Agent: SoftwareUpdateOperation

        SM Agent-&gt;&gt;SM Agent: Persist SoftwareUpdateOperation in-progress
        SM Agent-&gt;&gt;Cloud Mapper: SoftwareUpdateOperation EXECUTING

        loop Each plugin
            SM Agent-&gt;&gt;Software Plugin: plugin-cmd prepare
            Software Plugin--&gt;&gt;SM Agent: Exit code + stdout/stderr
        end

        loop Each module in SoftwareUpdateOperation module list
            alt If module action is install
                SM Agent-&gt;&gt;Software Plugin: plugin-cmd install module
            else
                SM Agent-&gt;&gt;Software Plugin: plugin-cmd uninstall module
            end
            Software Plugin--&gt;&gt;SM Agent: Exit code + stdout/stderr
        end

        loop Each plugin
            SM Agent-&gt;&gt;Software Plugin: plugin-cmd finalize
            Software Plugin--&gt;&gt;SM Agent: Exit code + stdout/stderr

            SM Agent-&gt;&gt;Software Plugin: plugin-cmd list
            Software Plugin--&gt;&gt;SM Agent: list cmd output
        end

        SM Agent-&gt;&gt;Cloud Mapper: SoftwareList

        alt If SoftwareUpdateOperation successful and SoftwareListStatus successful
            SM Agent-&gt;&gt;Cloud Mapper: SoftwareUpdateOperation SUCCESSFUL
        else
            SM Agent-&gt;&gt;Cloud Mapper: SoftwareUpdateOperation FAILED
        end

        SM Agent--&gt;&gt;SM Agent: Clear SoftwareUpdateOperation in-progress flag from persistence store
    end
</pre>
<p>The SM Agent will process only one <code>SoftwareUpdateOperation</code> at a time.
If a duplicate operation is received while in the middle of processing one operation, the new request will be ignored.
Ignoring is okay as the SM Agent expects to retrieve it later on, after the current operation processing is complete, from the mapper via its PENDING requests queue.
The mapper can choose to persist such PENDING requests on its own if the cloud that it supports doesn't support such queueing.
But, the SM Agent won't persist such requests.</p>
<p>While processing the software update list, the modules are installed/uninstalled in the order that they were received from the cloud. However the SW update operation is a &quot;declarative&quot; operation by definition, so there is no intentional order from the Cloud operator. Instead the SM agent can define an order that fits best so that the intended package amount defined by the sw-list will be achieved.</p>
<p>NOTE for Furture extension: If the order need to be decided by a specific Package Manager (e.g. to consider/fix dependencies between packages in the sw-list) the Package Manager plugin should be able to be feeded with all packages of according type at once, instead of package by package. Therefore the Package Manager Plugin API will be extended with another command (proposed name &quot;exec-list&quot;) later.</p>
<p>While installing/uinstalling the modules one by one, we have the option to either fail-fast as soon as one installation/uninstallation fails or keep track of the failures and continue installing/uninstalling the rest of the software modules.
Fail-fast would be a better choice as in the case of a failure, the user is more likely to retry that operation after making any changes to the original software update list that he prepared.</p>
<p>Once the mapper receives the SUCCESSFUL or FAILED status for an update operation from the SM Agent,
it can send the next PENDING <code>SoftwareUpdateOperation</code> to the SM Agent and the whole request processing cycle will repeat.</p>
<h1 id="thin-edge-json-specification-for-commands"><a class="header" href="#thin-edge-json-specification-for-commands">Thin Edge JSON Specification for Commands</a></h1>
<p>A topic scheme like <code>tedge/commands/req/&lt;component&gt;/&lt;action&gt;</code> is used for inbound operation requests.
The corresponding operation response need to be sent to <code>tedge/commands/res/&lt;component&gt;/&lt;action&gt;</code>.
In the future we can add sub actions as well, as in <code>tedge/commands/req/&lt;component&gt;/&lt;action&gt;/&lt;sub-action&gt;</code> 
or even more levels in the topic hierarchy, if needed.</p>
<p>For example, the request to fetch the software list from the agent needs to be sent to <code>tedge/commands/req/software/list</code> and the corresponding software list response will be sent to <code>tedge/commands/res/software/list</code>.
Similar scheme can be used for other operations as well in future as captured in the following table:</p>
<table><thead><tr><th>Operation</th><th>Request Topic</th><th>Response Topic</th></tr></thead><tbody>
<tr><td>Get Software List</td><td><code>tedge/commands/req/software/list</code></td><td><code>tedge/commands/res/software/list</code></td></tr>
<tr><td>Software Update</td><td><code>tedge/commands/req/software/update</code></td><td><code>tedge/commands/res/software/update</code></td></tr>
<tr><td>Sync Software List</td><td><code>tedge/commands/req/software/sync</code></td><td><code>tedge/commands/res/software/sync</code></td></tr>
<tr><td>Apply Profile</td><td><code>tedge/commands/req/profile/apply</code></td><td><code>tedge/commands/res/profile/apply</code></td></tr>
<tr><td>Get Configuration</td><td><code>tedge/commands/req/configuration/get</code></td><td><code>tedge/commands/res/configuration/get</code></td></tr>
<tr><td>Set Configuration</td><td><code>tedge/commands/req/configuration/set</code></td><td><code>tedge/commands/res/configuration/set</code></td></tr>
<tr><td>Get Log</td><td><code>tedge/commands/req/log/get</code></td><td><code>tedge/commands/res/log/get</code></td></tr>
<tr><td>Restart  device</td><td><code>tedge/commands/req/control/restart</code></td><td><code>tedge/commands/res/control/restart</code></td></tr>
<tr><td>Remote  connect</td><td><code>tedge/commands/req/control/connect</code></td><td><code>tedge/commands/res/control/connect</code></td></tr>
</tbody></table>
<p>Having such dedicated topics for each command enables Thin Edge components to selectively subscribe to only the commands that they're interested in.
If one component wants to subscribe to all commands for a single component like <code>software</code>, it can still subscribe to <code>tedge/commands/req/software/#</code>.
If one component wants to subscribe to all commands, then it can even subscribe to <code>tedge/commands/req/#</code>.</p>
<h2 id="ordering-of-operations-along-multiple-topics"><a class="header" href="#ordering-of-operations-along-multiple-topics">Ordering of operations along multiple topics</a></h2>
<p>Since MQTT doesn't guarantee ordered delivery of messages across different topics, the ordering of actions for a single component,
or even the ordering of actions between different components will have to be controlled by the publisher, which is the <code>Cloud Mapper</code>.
When strict ordering is required between commands, like a software update command followed by a device restart command,
the <code>Cloud Mapper</code> needs to issue the software update request first, wait for its response and only then issue the device restart request.
It can also send unordered commands like a log request or remote control parallelly, even when some other ordered commands are being executed.</p>
<h1 id="thin-edge-json-specification-for-software-management-commands"><a class="header" href="#thin-edge-json-specification-for-software-management-commands">Thin Edge JSON Specification for Software Management Commands</a></h1>
<h2 id="declaring-capabilities"><a class="header" href="#declaring-capabilities">Declaring Capabilities</a></h2>
<p>Topics to publish the request to:</p>
<ul>
<li>For software update: <code>tedge/capabilities/software/update</code></li>
<li>For software list: <code>tedge/capabilities/software/list</code></li>
<li>For software sync: <code>tedge/capabilities/software/sync</code></li>
</ul>
<p>There's no payload to send.</p>
<p>The mapper, on receipt of this request will publish any PENDING operations of that kind to the designated topics like <code>tedge/commands/req/software/list</code>, <code>tedge/commands/req/configuration/set</code> etc.
If there are no PENDING operations of that kind, then mapper won't send any response.</p>
<h2 id="software-list-operation"><a class="header" href="#software-list-operation">Software List Operation</a></h2>
<h3 id="thin-edge-json-software-list-request"><a class="header" href="#thin-edge-json-software-list-request">Thin Edge JSON Software List Request</a></h3>
<p>Topic to publish the software list request to: <code>tedge/commands/req/software/list</code></p>
<p>Request payload: </p>
<pre><code class="language-json">{
    &quot;id&quot;: 123
}
</code></pre>
<p>Some unique id must be generated by the requestor and this <code>id</code> is sent back in the response for correlation.</p>
<h3 id="thin-edge-json-software-list-response"><a class="header" href="#thin-edge-json-software-list-response">Thin Edge JSON Software List Response</a></h3>
<p>Topic to subscribe for the software list response: <code>tedge/commands/res/software/list</code></p>
<p>Payload format:</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;: &quot;successful&quot;,
    &quot;currentSoftwareList&quot;: [
        {
            &quot;type&quot;: &quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nodered&quot;,
                    &quot;version&quot;: &quot;1.0.0&quot;
                },
                {
                    &quot;name&quot;: &quot;collectd&quot;,
                    &quot;version&quot;: &quot;5.7&quot;
                }
            ]
        },
        {
            &quot;type&quot;: &quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nginx&quot;,
                    &quot;version&quot;: &quot;1.21.0&quot;
                },
                {
                    &quot;name&quot;: &quot;mongodb&quot;,
                    &quot;version&quot;: &quot;4.4.6&quot;
                }
            ]
        }
    ]
}
</code></pre>
<p><strong>Payload fields:</strong></p>
<p>In the top-level array, there will be one entry each for every plugin on the device, if the plugin reports a non-empty software list, when queried for one.</p>
<ul>
<li><code>id</code> is used to correlate any response from the mapper while processing the software list. If the mapper fails to process the list, the error will published </li>
<li><code>type</code> captures the type of software module that's being reported in the list.
It will be the name of the plugin that reports this list.
It can be optional and can be empty for the default software module type of the device, if a default plugin is configured on the device.</li>
<li><code>list</code> is an array of software modules represented as JSON objects. This field is mandatory.</li>
<li><code>name</code> in the software module JSON captures the name of the software module, which is mandatory.</li>
<li><code>version</code> in the software module JSON captures the name of the software module, which is optional.</li>
</ul>
<p>If fetching the software list had failed, the reponse would have indicated a failure as follows:</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;: &quot;failed&quot;,
    &quot;reason&quot;: &quot;Request timed-out&quot;
}
</code></pre>
<h4 id="executing-status-payload"><a class="header" href="#executing-status-payload">Executing Status Payload</a></h4>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;: &quot;executing&quot;
}
</code></pre>
<h2 id="software-update-operation"><a class="header" href="#software-update-operation">Software Update Operation</a></h2>
<h3 id="thin-edge-json-software-update-request"><a class="header" href="#thin-edge-json-software-update-request">Thin Edge JSON Software Update Request</a></h3>
<p>Topic to subscribe to: <code>tedge/commands/req/software/update</code></p>
<p>Payload format:</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;updateList&quot;: [
        {
            &quot;type&quot;: &quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nodered&quot;,
                    &quot;version&quot;: &quot;1.0.0&quot;,
                    &quot;action&quot;: &quot;install&quot;
                },
                {
                    &quot;name&quot;: &quot;collectd&quot;,
                    &quot;version&quot;: &quot;5.7&quot;,
                    &quot;url&quot;: &quot;https://collectd.org/download/collectd-tarballs/collectd-5.12.0.tar.bz2&quot;,
                    &quot;action&quot;: &quot;install&quot;
                }
            ]
        },
        {
            &quot;type&quot;: &quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nginx&quot;,
                    &quot;version&quot;: &quot;1.21.0&quot;,
                    &quot;action&quot;: &quot;install&quot;
                },
                {
                    &quot;name&quot;: &quot;mongodb&quot;,
                    &quot;version&quot;: &quot;4.4.6&quot;,
                    &quot;action&quot;: &quot;remove&quot;
                }
            ]
        }
    ]
}
</code></pre>
<h3 id="thin-edge-json-software-update-response"><a class="header" href="#thin-edge-json-software-update-response">Thin Edge JSON Software Update Response</a></h3>
<p>Once a software-update operation is received, it must be acknowledged with an EXECUTING response, followed by a SUCCESSFUL or FAILED response.</p>
<p>Topic to subscribe for the software update response: <code>tedge/commands/res/software/update</code></p>
<h4 id="executing-status-payload-1"><a class="header" href="#executing-status-payload-1">Executing Status Payload</a></h4>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;: &quot;executing&quot;
}
</code></pre>
<h4 id="successful-status-payload"><a class="header" href="#successful-status-payload">Successful Status Payload</a></h4>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;: &quot;successful&quot;,
    &quot;currentSoftwareList&quot;: [
        {
            &quot;type&quot;: &quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nodered&quot;,
                    &quot;version&quot;: &quot;1.0.0&quot;,
                },
                {
                    &quot;name&quot;: &quot;collectd&quot;,
                    &quot;version&quot;: &quot;5.7&quot;
                }
            ]
        },
        {
            &quot;type&quot;: &quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nginx&quot;,
                    &quot;version&quot;: &quot;1.21.0&quot;,
                },
                {
                    &quot;name&quot;: &quot;mongodb&quot;,
                    &quot;version&quot;: &quot;4.4.6&quot;,
                }
            ]
        }
    ]
}
</code></pre>
<p>Sending the current software list along with the status will help the cloud providers to show the most up-to-date software list after an update was performed, which would include any extra dependencies that got installed/removed as part of the update.</p>
<h4 id="failed-status-payload"><a class="header" href="#failed-status-payload">Failed Status Payload</a></h4>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;:&quot;failed&quot;,
    &quot;reason&quot;:&quot;Partial failure: Couldn't install collectd and nginx&quot;,
    &quot;currentSoftwareList&quot;: [
        {
            &quot;type&quot;: &quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nodered&quot;,
                    &quot;version&quot;: &quot;1.0.0&quot;,
                }
            ]
        },
        {
            &quot;type&quot;: &quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nginx&quot;,
                    &quot;version&quot;: &quot;1.21.0&quot;,
                }
            ]
        }
    ],
    &quot;failures&quot;:[
        {
            &quot;type&quot;:&quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;:&quot;collectd&quot;,
                    &quot;version&quot;:&quot;5.7&quot;,
                    &quot;action&quot;:&quot;install&quot;,
                    &quot;reason&quot;:&quot;Network timeout&quot;
                }
            ]
        },
        {
            &quot;type&quot;:&quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;mongodb&quot;,
                    &quot;version&quot;: &quot;4.4.6&quot;,
                    &quot;action&quot;:&quot;remove&quot;,
                    &quot;reason&quot;:&quot;Other components dependent on it&quot;
                }
            ]
        }
    ]
}
</code></pre>
<p>Sending the <code>currentSoftwareList</code> along with the status even in the case of a failure will help the cloud providers to show the most up-to-date software list,
especially in the case of partial failures, which would contain the modules and dependencies that got installed,
even though the overall update failed.</p>
<p>The <code>failures</code> fragment captures the modules that could not be installed/uninstalled with the reason reported by the software plugin.
If we skip the installation/uninstallation of some modules because of earlier failures,
the failure <code>reason</code> can be reorted as <code>Skipped</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c8y-mapper-operation-handling"><a class="header" href="#c8y-mapper-operation-handling">C8Y Mapper Operation Handling</a></h1>
<p><em>!!ATTENTION!! We support only <code>c8y_SoftwareUpdate</code> in the release <code>0.3</code>. 
Ignore <code>c8y_DeviceProfile</code> for now.</em></p>
<p>In this page, we focus on the contract between C8Y Mapper and C8Y Cloud. 
If you want to know the mapping rules, 
please refer to <a href="software-management/./thin-edge-json-mapping-to-from-c8y.html">Thin Edge JSON Mapping to/from C8Y</a>.</p>
<h2 id="flow-at-sm-agent-startup"><a class="header" href="#flow-at-sm-agent-startup">Flow at SM Agent Startup</a></h2>
<pre class="mermaid">sequenceDiagram
    participant SM Agent
    participant C8Y Mapper
    participant C8Y Cloud

    alt If SM Agent reports failure of last SoftwareUpdateOperation on a startup
      SM Agent -&gt;&gt; C8Y Mapper: Operation status FAILED + current SoftwareList
      C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 502: Update operation status to FAILED
      C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 116: Send current c8y_SoftwareList
    end

    SM Agent -&gt;&gt; C8Y Mapper: Declare SoftwareUpdate and SoftwareList capability
    C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 114: Send c8y_SoftwareUpdate as SupportedOperations
    
    alt If receiving both SoftwareUpdate and SoftwareList capabilities
      C8Y Mapper -&gt;&gt; SM Agent: Software List Request
      SM Agent --&gt;&gt; C8Y Mapper: Software List
      C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 116: Send current c8y_SoftwareList
      
      C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 500: Get PENDING operations
      C8Y Cloud --&gt;&gt; C8Y Mapper: SmartREST 528: SoftwareUpdate operation and others
      Note right of C8Y Mapper: the following flow is the same as the flow in runtime
    end
</pre>
<table><thead><tr><th>ID</th><th>Description</th><th>Example Payload</th><th>Type</th></tr></thead><tbody>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name502set-operation-to-failed-502a">502</a></td><td>Set operation to FAILED</td><td><code>502,c8y_SoftwareUpdate,&quot;Permission denied&quot;</code></td><td>Publish</td></tr>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name116set-software-list-116a">116</a></td><td>Set software list</td><td><code>116,software1,version1,url1,software2,version2,url2</code></td><td>Publish</td></tr>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name114set-supported-operations-114a">114</a></td><td>Set supported operations</td><td><code>114,c8y_SoftwareUpdate</code></td><td>Publish</td></tr>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name500get-pending-operations-500a">500</a></td><td>Get PENDING operations</td><td><code>500</code></td><td>Publish</td></tr>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name528update-software-528a">528</a></td><td>Update Software</td><td><code>528,external_id,software1,version1,url1,install,software2,version2,url2,delete</code></td><td>Subscribe</td></tr>
</tbody></table>
<p>This flow is consists of 4 parts.</p>
<ol>
<li>Report operation failed to C8Y Cloud.</li>
<li>Receive device capabilities from SM Agent and translate as <code>C8Y_SupportedOperatons</code> and report them to C8Y Cloud.</li>
<li>Trigger a Set Software List request to SM Agent as a response of receiving Software List capability. </li>
<li>Trigger a Get PENDING operations request to C8Y Cloud as a response of receiving Software Update capability.</li>
</ol>
<p>Both &quot;SM Agent is up but C8Y Mapper is down&quot; and &quot;SM Agent is down but C8Y Mapper is up&quot; cases must be considered here.
Namely, the device capabilities must be delivered to C8Y Mapper in any case.</p>
<p>Other notes:</p>
<ul>
<li>Collecting all device's capabilities (e.g. SoftwareUpdate, Restart, etc.) are required 
so that the mapper sends SmartREST <code>114</code> with all necessary supported operations.</li>
<li>SM Agent might publish more capabilities than C8Y cloud supports. 
In this case, the mapper doesn't need to subscribe the unsupported capability topics.</li>
<li><code>c8y_SoftwareUpdate</code> is supported in c8y version 10.7 and onwards.</li>
<li>C8Y mapper can consider that the SM Agent is ready for a new operation 
after the agent publishes device's capabilities.</li>
<li>SmartREST <code>500</code> returns all the operations in the status <code>PENDING</code>.</li>
<li>SmartREST <code>500</code> may return not only <code>528</code>.</li>
</ul>
<h2 id="flow-in-runtime-phase-for-c8y_softwareupdate-operation"><a class="header" href="#flow-in-runtime-phase-for-c8y_softwareupdate-operation">Flow in runtime phase for <code>c8y_SoftwareUpdate</code> operation</a></h2>
<pre class="mermaid">sequenceDiagram
    participant SM Agent
    participant C8Y Mapper
    participant C8Y Cloud
    
    C8Y Cloud -&gt;&gt; C8Y Mapper: SmartREST 528: SoftwareUpdate operation and others
    C8Y Mapper -&gt;&gt; C8Y Mapper: Put operations to FIFO queue
    C8Y Mapper -&gt;&gt; C8Y Mapper: Wait until the SM Agent completes processing the last SoftwareUpdate operation(if any)
    C8Y Mapper -&gt;&gt; C8Y Mapper: Pick up the oldest c8y_SoftwareUpdate operation

    C8Y Mapper -&gt;&gt; SM Agent: Software Update Request
    
    SM Agent -&gt;&gt; C8Y Mapper: Operation status EXECUTING
    C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 501: Update operation status to EXECUTING
        
    alt software update successful
        SM Agent -&gt;&gt; C8Y Mapper: Operation status SUCCESSFUL + current SoftwareList
        alt the size of software list is small enough
            C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 116: Send current c8y_SoftwareList
            C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 503: Update operation status to SUCCESSFUL
        else the size of software list is above the threshold 
            C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 502: Update operation status to FAILED
        end
    else software update failed
        SM Agent -&gt;&gt; C8Y Mapper: Operation status FAILED + current SoftwareList
        C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 116: Send current c8y_SoftwareList
        C8Y Mapper -&gt;&gt; C8Y Cloud: SmartREST 502: Update operation status to FAILED
    end
</pre>
<table><thead><tr><th>ID</th><th>Description</th><th>Example Payload</th><th>Type</th></tr></thead><tbody>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name528update-software-528a">528</a></td><td>Update Software</td><td><code>528,external_id,software1,version1,url1,install,software2,version2,url2,delete</code></td><td>Subscribe</td></tr>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name501set-operation-to-executing-501a">501</a></td><td>Set operation to EXECUTING</td><td><code>501,c8y_SoftwareUpdate</code></td><td>Publish</td></tr>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name116set-software-list-116a">116</a></td><td>Set software list</td><td><code>116,software1,version1,url1,software2,version2,url2</code></td><td>Publish</td></tr>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name503set-operation-to-successful-503a">503</a></td><td>Set operation to SUCCESSFUL</td><td><code>503,c8y_SoftwareUpdate</code></td><td>Publish</td></tr>
<tr><td><a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-name502set-operation-to-failed-502a">502</a></td><td>Set operation to FAILED</td><td><code>502,c8y_SoftwareUpdate,&quot;Permission denied&quot;</code></td><td>Publish</td></tr>
</tbody></table>
<p>Note:</p>
<ul>
<li>C8Y cloud might publish <code>c8y_SoftwareUpdate</code>(<code>528</code>) and also other operations.</li>
<li>The mapper has responsibility to keep all received PENDING operations in FIFO queue.</li>
<li>The mapper considers that SM Agent is ready for receiving a new operation 
either <strong>when it receives Operation status SUCCESSFUL/FAILED + current SoftwareList</strong> 
or <strong>when it receives device capability (at agent startup only)</strong>.</li>
<li>SM Agent can process only one Software Update operation at one time. 
Therefore, c8y Mapper should pick up the oldest c8y_SoftwareUpdate operation.</li>
<li>C8Y UI blocks to create more than one <code>c8y_SoftwareUpdate</code> operation at the same time. 
However, still user can create more than one operation from REST API.</li>
<li>If one operation includes a couple of packages updates, and if one of those package failed, 
we have to send <code>FAILED</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapping-tofrom-c8y"><a class="header" href="#mapping-tofrom-c8y">Mapping to/from C8Y</a></h1>
<h2 id="device-capabilities"><a class="header" href="#device-capabilities">Device Capabilities</a></h2>
<h3 id="interpret-device-capabilities-to-smartrest-set-supported-operations-114"><a class="header" href="#interpret-device-capabilities-to-smartrest-set-supported-operations-114">Interpret Device Capabilities to SmartREST Set Supported Operations (114)</a></h3>
<p>Device capabilities are reported as empty messages published to dedicated topics.</p>
<table><thead><tr><th>Name in Thin Edge</th><th>Topic</th><th>C8Y Name</th></tr></thead><tbody>
<tr><td>Software Update</td><td>tedge/capabilities/software/update</td><td>c8y_SoftwareUpdate</td></tr>
<tr><td>Software List</td><td>tedge/capabilities/software/list</td><td>unused</td></tr>
<tr><td>Software Sync</td><td>tedge/capabilities/software/sync</td><td>unused</td></tr>
</tbody></table>
<p>C8Y Mapper needs to report only <code>c8y_SoftwareUpdate</code> from this table,
therefore, the mapper needs to subscribe only <code>tedge/capabilities/software/update</code>.
If the mapper observed that an empty payload message is published, the mapper</p>
<ol>
<li>publishes an empty payload message to <code>tedge/capabilities/software/update</code> to clear the retained message.</li>
<li>publishes SmartREST(114) to <code>c8y/s/us</code> as follwing.</li>
</ol>
<pre><code>114,c8y_SoftwareUpdate
</code></pre>
<p><em><strong>Future Extension:</strong></em><br />
If C8Y Mapper supports more than <code>c8y_SoftwareUpdate</code> operation (e.g. <code>c8y_Restart</code>),
the mapper should subscribe more capabilities topics,
and sends corresponded C8Y SupportedOpeation types with one <code>114</code> message.</p>
<h2 id="software-list-operation-1"><a class="header" href="#software-list-operation-1">Software List Operation</a></h2>
<h3 id="send-thin-edge-json-software-list-request"><a class="header" href="#send-thin-edge-json-software-list-request">Send Thin Edge JSON Software List Request</a></h3>
<p>Outgoing on the topic <code>tedge/commands/req/software/list</code> to SM Agent.</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123
}
</code></pre>
<p>The mapper must generate a unique ID.
Refer to <a href="software-management/../sm-agent.html">SM Agent specification</a> for more details.</p>
<h3 id="translate-from-thin-edge-json-software-list-response-to-smartrest-set-software-list-116"><a class="header" href="#translate-from-thin-edge-json-software-list-response-to-smartrest-set-software-list-116">Translate from Thin Edge JSON Software List Response to SmartREST Set Software List (116)</a></h3>
<p>The Thin Edge JSON message comes on the topic <code>tedge/commands/res/software/list</code> from SM Agent.</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;: &quot;successful&quot;,
    &quot;currentSoftwareList&quot;: [
        {
            &quot;type&quot;: &quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nodered&quot;,
                    &quot;version&quot;: &quot;1.0.0&quot;
                },
                {
                    &quot;name&quot;: &quot;collectd&quot;,
                    &quot;version&quot;: &quot;5.7&quot;
                }
            ]
        },
        {
            &quot;type&quot;: &quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nginx&quot;,
                    &quot;version&quot;: &quot;1.21.0&quot;
                },
                {
                    &quot;name&quot;: &quot;mongodb&quot;,
                    &quot;version&quot;: &quot;4.4.6&quot;
                }
            ]
        }
    ]
}
</code></pre>
<p>The mapper translates the Thin Edge JSON message to SmartREST (116) format. </p>
<p>We set rules how to represent <code>type</code> in C8Y Cloud
since C8Y doesn't have <code>type</code> field in <code>c8y_SoftwareList</code> structure.</p>
<ul>
<li>The mapper adds <code>type</code> as a suffix of a package <strong>version</strong> after <code>::</code> (double-colon) 
if provided. If a version contains <code>::</code>, the mapper adds <code>::</code> at the end of version 
even the <code>type</code> is default.
<ul>
<li>Example 1: if the package type is <code>debian</code>, and the version is <code>1.0.0</code>,
the version that the mapper reports is <code>1.0.0::debian</code>.</li>
<li>Example 2: if the package type is blank (meaning the agent uses the &quot;default&quot; type),
and the version is <code>1.0.0</code>, the version that the mapper reports is <code>1.0.0</code>.</li>
<li>Example 3: if the package type is <code>debian</code>, 
and the version is <code>1.0.0::1</code> (containing <code>::</code> delimiter as a package version),
the version that mapper reports is <code>1.0.0::1::debian</code>.</li>
<li>Example 4 (corner case): if the package type is blank,
and the version is <code>1.0.0::1</code> (containing <code>::</code> delimiter as a package version),
the version that mapper reports is <code>1.0.0::1::</code>.</li>
</ul>
</li>
<li>Keep URL fields blank.</li>
</ul>
<p>The SmartREST(116) message goes out on the topic <code>c8y/s/us</code> to Mosquitto bridge.</p>
<pre><code>116,nodered,1.0.0::debian,,collectd,5.7::debian,,nginx,1.21.0::docker,,mongodb,4.4.6::docker,
</code></pre>
<h2 id="software-update-operation-1"><a class="header" href="#software-update-operation-1">Software Update Operation</a></h2>
<h3 id="send-smartrest-500-get-pending-operations"><a class="header" href="#send-smartrest-500-get-pending-operations">Send SmartREST 500 Get PENDING operations</a></h3>
<p>The SmartREST 500 message goes out on the topic <code>c8y/s/us</code> to Mosquitto bridge.</p>
<pre><code>500
</code></pre>
<p>Then, the mapper will receive PENDING operations if they exist.</p>
<h3 id="translate-from-smartrest-software-update-operation-528-to-thin-edge-json-software-update-request"><a class="header" href="#translate-from-smartrest-software-update-operation-528-to-thin-edge-json-software-update-request">Translate from SmartREST Software Update Operation (528) to Thin Edge JSON Software Update Request</a></h3>
<p>The SmartREST <code>528</code> message comes onto the topic <code>c8y/s/ds</code> from C8Y Cloud.</p>
<pre><code>528,external_id,nodered,1.0.0::debian, ,install,collectd,5.7::debian,https://collectd.org/download/collectd-tarballs/collectd-5.12.0.tar.bz2,install,nginx,1.21.0::docker, ,install,mongodb,4.4.6::docker,,delete
</code></pre>
<p>There are rules how to convert from SmartREST to ThinEdgeJSON.</p>
<ol>
<li>Mapper gets <code>type</code> from the version. 
Check where is the last <code>::</code> (double-colon) and assume that the keyword after the last <code>::</code> is the type.
<ul>
<li>If nothing follows after the last <code>::</code>, the mapper considers the <code>type</code> is &quot;default&quot;.
e.g. <code>1.0.0::1::</code></li>
</ul>
</li>
<li>If no <code>::</code> is provided in a version, the mapper considers the <code>type</code> is &quot;default&quot;.
Namely, leave the value of <code>type</code> blank.</li>
<li>If the <code>URL</code> field is empty or a &quot; &quot; (space), mapper considers that the package should be installed from the standard repository.</li>
</ol>
<p>Then, the translated Thin Edge JSON goes on the topic <code>tedge/commands/req/software/update</code> to SM Agent.</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;updateList&quot;: [
        {
            &quot;type&quot;: &quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nodered&quot;,
                    &quot;version&quot;: &quot;1.0.0&quot;,
                    &quot;action&quot;: &quot;install&quot;
                },
                {
                    &quot;name&quot;: &quot;collectd&quot;,
                    &quot;version&quot;: &quot;5.7&quot;,
                    &quot;url&quot;: &quot;https://collectd.org/download/collectd-tarballs/collectd-5.12.0.tar.bz2&quot;,
                    &quot;action&quot;: &quot;install&quot;
                }
            ]
        },
        {
            &quot;type&quot;: &quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nginx&quot;,
                    &quot;version&quot;: &quot;1.21.0&quot;,
                    &quot;action&quot;: &quot;install&quot;
                },
                {
                    &quot;name&quot;: &quot;mongodb&quot;,
                    &quot;version&quot;: &quot;4.4.6&quot;,
                    &quot;action&quot;: &quot;remove&quot;
                }
            ]
        }
    ]
}
</code></pre>
<p><strong>Attention</strong>:</p>
<ul>
<li>Uninstallation terminologies are different in C8Y and Thin Edge JSON. C8Y uses <code>delete</code>, 
although Thin Edge JSON uses <code>remove</code>.</li>
</ul>
<h3 id="translate-from-thin-edge-json-software-update-executing-to-smartrest-operation-update-executing-501"><a class="header" href="#translate-from-thin-edge-json-software-update-executing-to-smartrest-operation-update-executing-501">Translate from Thin Edge JSON Software Update Executing to SmartREST Operation Update EXECUTING (501)</a></h3>
<p>Incoming to <code>tedge/commands/res/software/update</code> from SM Agent.</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;: &quot;EXECUTING&quot;
}
</code></pre>
<p>The mapper translates it and publishes on <code>c8y/s/us</code>.</p>
<pre><code>501,c8y_SoftwareUpdate
</code></pre>
<h3 id="translate-from-thin-edge-json-software-list-response-successful-to-smartrest-set-software-list-116-and-operation-update-successful-503"><a class="header" href="#translate-from-thin-edge-json-software-list-response-successful-to-smartrest-set-software-list-116-and-operation-update-successful-503">Translate from Thin Edge JSON Software List Response (Successful) to SmartREST Set Software List (116) and Operation Update SUCCESSFUL (503)</a></h3>
<p>The Thin Edge JSON message comes onto the topic <code>tedge/commands/res/software/update</code> from SM Agent.</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;: &quot;successful&quot;,
    &quot;currentSoftwareList&quot;: [
        {
            &quot;type&quot;: &quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nodered&quot;,
                    &quot;version&quot;: &quot;1.0.0&quot;
                },
                {
                    &quot;name&quot;: &quot;collectd&quot;,
                    &quot;version&quot;: &quot;5.7&quot;
                }
            ]
        },
        {
            &quot;type&quot;: &quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nginx&quot;,
                    &quot;version&quot;: &quot;1.21.0&quot;
                },
                {
                    &quot;name&quot;: &quot;mongodb&quot;,
                    &quot;version&quot;: &quot;4.4.6&quot;
                }
            ]
        }
    ]
}
</code></pre>
<p>The mapper translates it into two messages and publishes onto <code>c8y/s/us</code>.</p>
<p>The first message is SmartREST <code>116</code>, that is <code>c8y_SoftwareList</code>.
The translation rules are the same as described in 
<a href="software-management/thin-edge-json-mapping-to-from-c8y.html#translate-from-thin-edge-json-software-list-response-to-smartrest-set-software-list-116">From Thin Edge JSON Software List Response to c8y_SoftwareList (116)</a>.</p>
<p>The second message is operation update to <code>SUCCESSFUL</code>.</p>
<pre><code>503,c8y_SoftwareUpdate
</code></pre>
<h3 id="translate-from-thin-edge-json-software-update-operation-failed-to-smartrest-set-software-list-116-and-operation-update-failed-502"><a class="header" href="#translate-from-thin-edge-json-software-update-operation-failed-to-smartrest-set-software-list-116-and-operation-update-failed-502">Translate from Thin Edge JSON Software Update Operation FAILED to SmartREST Set Software List (116) and Operation Update FAILED (502)</a></h3>
<p>The Thin Edge JSON message comes on the topic <code>tedge/commands/res/software/update</code> from SM Agent.</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;status&quot;:&quot;failed&quot;,
    &quot;reason&quot;:&quot;Partial failure: Couldn't install collectd and nginx&quot;,
    &quot;currentSoftwareList&quot;: [
        {
            &quot;type&quot;: &quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nodered&quot;,
                    &quot;version&quot;: &quot;1.0.0&quot;
                }
            ]
        },
        {
            &quot;type&quot;: &quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;nginx&quot;,
                    &quot;version&quot;: &quot;1.21.0&quot;
                }
            ]
        }
    ],
    &quot;failures&quot;:[
        {
            &quot;type&quot;:&quot;debian&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;:&quot;collectd&quot;,
                    &quot;version&quot;:&quot;5.7&quot;,
                    &quot;action&quot;:&quot;install&quot;,
                    &quot;reason&quot;:&quot;Network timeout&quot;
                }
            ]
        },
        {
            &quot;type&quot;:&quot;docker&quot;,
            &quot;modules&quot;: [
                {
                    &quot;name&quot;: &quot;mongodb&quot;,
                    &quot;version&quot;: &quot;4.4.6&quot;,
                    &quot;action&quot;:&quot;remove&quot;,
                    &quot;reason&quot;:&quot;Other components dependent on it&quot;
                }
            ]
        }
    ]
}
</code></pre>
<p>The mapper translates the Thin Edge JSON to SmartREST <code>116</code> and <code>502</code> then publishes them to <code>c8y/s/us</code>.</p>
<p>The first message is SmartREST <code>116</code>, that is <code>c8y_SoftwareList</code>.
The translation rules are the same as described in 
<a href="software-management/thin-edge-json-mapping-to-from-c8y.html#translate-from-thin-edge-json-software-list-response-to-smartrest-set-software-list-116">From Thin Edge JSON Software List Response to c8y_SoftwareList (116)</a>.</p>
<p>The second message is operation update to <code>FAILED</code> with a following rule.</p>
<ul>
<li>Use the only parent field <code>reason</code> as a failure reason to report.</li>
</ul>
<pre><code>502,c8y_SoftwareUpdate,&quot;Partial failure: Couldn't install collectd and nginx&quot;
</code></pre>
<h3 id="send-smartrest-operation-update-failed-502-only-if-sending-softwarelist-116-failed"><a class="header" href="#send-smartrest-operation-update-failed-502-only-if-sending-softwarelist-116-failed">Send SmartREST Operation Update FAILED (502) only if sending SoftwareList (116) failed</a></h3>
<p>It's possible that sending <code>c8y_SoftwareList</code> (116) fails due to the huge payload size.
In this case, the mapper should send only operation <code>FAILED</code> to C8Y cloud.</p>
<p>Topic to publish: <code>c8y/s/us</code>,</p>
<pre><code>502,c8y_SoftwareUpdate,&quot;Failed to send the current software list after software update operation&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-decisions"><a class="header" href="#open-decisions">Open Decisions</a></h1>
<p>That document lists open decisions in scope of thin-edge.</p>
<p>Each table below outlines an open decision to be made. </p>
<h2 id="open-decisions-about-software-management"><a class="header" href="#open-decisions-about-software-management">Open Decisions about Software Management</a></h2>
<h2 id="decision-001"><a class="header" href="#decision-001"><strong>Decision-001</strong></a></h2>
<p><strong>Problem Statement:</strong> When shall current sw-list reported to the cloud?</p>
<p><strong>Reference:</strong> Use Case Diagram &quot;SW Management&quot; (see reference &quot;TO-BE-DECIDED-#1&quot;): https://github.com/thin-edge/thin-edge.io-specs/blob/0cc561632947220cbf5d8a204be8a4a9ad9abb5a/src/software-management/README.md</p>
<p><strong>Option #1</strong></p>
<ul>
<li>
<p><strong>Description:</strong>  Just on Device/Agent start<br/></p>
</li>
<li>
<p><strong>Implications:</strong>  TBD<br/></p>
</li>
</ul>
<p><strong>Option #2</strong></p>
<ul>
<li>
<p><strong>Description:</strong> Periodically? (Last might capture also manually installed packages).<br/></p>
<p>See ref: https://app.archbee.io/docs/9iGX1hbDjwAeMfyO9A3YE/coxr9CuTWSjk0eE1Nzgoj <br/></p>
<p>-&gt; Section: &quot;Update Profile Operation&quot;<br/></p>
<p>-&gt; Snippet: &quot;As part of the above use cases, this use cases extracts the current software list from the device. [...] Additionally, this use cases could be called periodically by e.g. a cron job.&quot;.<br/></p>
</li>
<li>
<p><strong>Implications:</strong> TBD <br/></p>
</li>
</ul>
<p><strong>Comment:</strong> Due to agent's request-response-model periodically trigger can be realized outside of agent.</p>
<p> 
 
 
 
 
 </p>
<h2 id="decision-002"><a class="header" href="#decision-002"><strong>Decision-002</strong></a></h2>
<p><strong>Problem Statement:</strong> Some delta comparision shall occur at some place, to avoid installing already installed packages and avoid removing not existing ones. <br/></p>
<p>To be decided whether delta-comparision shall occur in SM Agent or Package Manager Plugin.</p>
<p><strong>Reference:</strong> Sequence Diagram &quot;Update SW-list&quot; (see reference &quot;TO-BE-DECIDED-#1&quot;): https://github.com/thin-edge/thin-edge.io-specs/blob/0cc561632947220cbf5d8a204be8a4a9ad9abb5a/src/software-management/usecase-update-swlist.md</p>
<p><strong>Option #1</strong></p>
<ul>
<li>
<p><strong>Description:</strong> Delta-comparision by SM Agent. <br/></p>
<p>See ref: https://app.archbee.io/docs/9iGX1hbDjwAeMfyO9A3YE/coxr9CuTWSjk0eE1Nzgoj <br/></p>
<p>-&gt; Section: &quot;Update Software Operation&quot; <br/></p>
<p>-&gt; Steps underneath &quot;The operation is executed as follows&quot; <br/></p>
<p>and <br/></p>
<p>-&gt; Section: &quot;Hiding Software Module&quot; <br/></p>
<p>-&gt; Snippet: &quot;Certain packages should not be uninstallable. By not listed them, they are also not uninstalled based on delta algorithm described under &quot;update software&quot; above (only software modules that are part of the current software list can be uninstalled.)&quot;</p>
</li>
<li>
<p><strong>Implications:</strong> TBD <br/></p>
</li>
</ul>
<p><strong>Option #2</strong></p>
<ul>
<li>
<p><strong>Description:</strong> Delta-comparision by Package Manager Plugins<br/></p>
<p>TODO: more Details will be added here.<br/></p>
</li>
<li>
<p><strong>Implications:</strong> TBD <br/></p>
</li>
</ul>
<p><strong>Comment:</strong> -</p>
<p> 
 
 
 
 
 </p>
<h2 id="decision-003"><a class="header" href="#decision-003"><strong>Decision-003</strong></a></h2>
<p><strong>Problem Statement:</strong> In which order shall items of sw-list be processed? Shall order from Cloud be kept, or shall thin-edge re-order the list for some reason?</p>
<p><strong>Reference:</strong> Sequence Diagram &quot;Update SW-list&quot; (see reference &quot;TO-BE-DECIDED-#2&quot;): https://github.com/thin-edge/thin-edge.io-specs/blob/0cc561632947220cbf5d8a204be8a4a9ad9abb5a/src/software-management/usecase-update-swlist.md</p>
<p><strong>Option #1</strong></p>
<ul>
<li>
<p><strong>Description:</strong>  Keeping order inside sw-list from Cloud to enable Cloud operator to dictate the order of processing.<br/></p>
</li>
<li>
<p><strong>Implications:</strong>  Would allow the cloud operator:<br/></p>
</li>
<li>
<p>to manage package dependencies<br/></p>
<p>   a) within on package type (E.g.: 1st install debain package &quot;foo&quot;, 2nd install debian package &quot;bar&quot;)<br/></p>
<p>   b) to manage package dependencies beyond package types (E.g.: 1st install debian package &quot;foo&quot;, 2nd install Docker package &quot;bar&quot;)<br/></p>
<p>   c) to install package type per package type (E.g.: 1st install all Debain packages, 2nd install Docker packages)<br/></p>
<p>NOTE: That or a similar solution would be required if Package Management auto-dependency solving is disabled or not available (see Decision 4). <br/></p>
<p>Pro: Gives Freedom to the Cloud Operator<br/></p>
<p>Con: Gives responsibility to the Cloud Operator <br/></p>
<p>Disadvantage: a) Not a declarative semantics anymore b) Cloud must have detail knowledge about package types on different devices, impossible to scale?<br/></p>
</li>
</ul>
<p><strong>Option #2</strong></p>
<ul>
<li>
<p><strong>Description:</strong>  Hardcoding some as best expected order into the agent. <br/></p>
<p>Example order:  - 1st process per package type (&quot;debian&quot;, ...) - then 2nd per operation (&quot;remove, install&quot;). <br/></p>
</li>
<li>
<p><strong>Implications:</strong> No chance to solve dependencies on Cloud-side. See also Decision 4. <br/></p>
</li>
</ul>
<p><strong>Option #3</strong></p>
<ul>
<li>
<p><strong>Description:</strong> Define plugin execution order inside agent, e.g. using numbers in the plugin filename? Example: <br/>- 01debain<br/>- 02docker<br/>- 03apama <br/></p>
</li>
<li>
<p><strong>Implications:</strong> TBD <br/></p>
</li>
</ul>
<p><strong>Comment:</strong> </p>
<p>D 
 
 
 
 
 </p>
<h2 id="decision-004"><a class="header" href="#decision-004"><strong>Decision-004</strong></a></h2>
<p><strong>Problem Statement:</strong> Shall auto dependency solving used if package manager supports it?</p>
<p><strong>Reference:</strong> None</p>
<p><strong>Option #1</strong></p>
<ul>
<li>
<p><strong>Description:</strong> Yes, let Package Manager solve dependencies automatically. <br/></p>
<p>See also ref https://app.archbee.io/docs/9iGX1hbDjwAeMfyO9A3YE/coxr9CuTWSjk0eE1Nzgoj <br/></p>
<p>-&gt; Section: &quot;Update Software Operation&quot; <br/></p>
<p>-&gt; Snippet: &quot;Just top-level packages are listed, because the software type specific Installer is responsible for dealing with dependency management.&quot; <br/></p>
</li>
<li>
<p><strong>Implications:</strong> Convenient for Cloud-Operator, but could lead to unexpected / problematic behaviour as below: <br/></p>
<p>-&gt; Could lead exceeded current sw-list size reported to cloud. Since Cloud operator is unknown of auto-dep installed package he could not fix that by added them to black-list / filter for current sw-list. <br/></p>
<p>-&gt; Could lead to unexpected flash capacity load, in case of large dependencies. <br/></p>
<p>-&gt; Could lead to invisible package on Cloud side (e.g. when auto-deps are blacklisted). These invisible package might be an issue from security point of view. They could be affected by vulnerabilities but Cloud Operator is not aware of these Packages (invisible). Even he would be aware of them he would not be able to update or remove them (invisible). <br/></p>
<p>See also ref https://app.archbee.io/docs/9iGX1hbDjwAeMfyO9A3YE/coxr9CuTWSjk0eE1Nzgoj <br/></p>
<p>-&gt; Section: &quot;Why is Software Management important&quot; <br/></p>
<p>-&gt; Snippet: &quot;As all other software too, also the software on the device needs to be updated to fix e.g. security bugs. This is even required by e.g. EU Standards.&quot;</p>
</li>
</ul>
<p><strong>Option #2</strong></p>
<ul>
<li>
<p><strong>Description:</strong>  No, prohibit that Package Manager solve dependencies automatically. <br/></p>
<p>Dependency Management need to be done on Cloud-side, e.g. by adding all depending package into the update sw-list request, in the correct order. <br/></p>
<p>See also Decision 3.</p>
</li>
<li>
<p><strong>Implications:</strong> More effort and responsibility for Cloud Operator. <br/></p>
</li>
</ul>
<p><strong>Option #3</strong></p>
<ul>
<li>
<p><strong>Description:</strong>  Assume the plugin will install the require dependencies but let the user a way to list them if not. This implies that the all the packages are installed in the order specified by the the cloud operator. However, the operator will have to provide the correct order with the full set of dependencies only for the plugin that requires it. <br/></p>
<p>See also Decision 3.</p>
</li>
<li>
<p><strong>Implications:</strong> More effort and responsibility for Cloud Operator. <br/></p>
</li>
</ul>
<p><strong>Comment:</strong> Could be finally decided by Customer by adapting according Package Manager Plugin. But if provide no way to solve dependencies manually (see Decision 3) thats not an option for the Customer. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="mermaid.min.js"></script>
                <script type="text/javascript" src="mermaid-init.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
